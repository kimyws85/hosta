<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 완벽 가이드</title>
    <!-- 파비콘 -->
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23F7DF1E'/%3E%3Cstop offset='100%25' stop-color='%23E5A00D'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='15' fill='url(%23g)'/%3E%3Ctext x='50' y='72' font-family='Arial Black' font-size='55' font-weight='bold' fill='%23323330' text-anchor='middle'%3EJS%3C/text%3E%3C/svg%3E">
    <!-- 폰트어썸 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 구글 폰트 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">
    <!-- Swiper CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css">
    <!-- 스타일시트 -->
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <!-- 진행률 표시 -->
    <div class="progress-bar">
        <div class="progress-fill"></div>
    </div>

    <!-- 헤더 -->
    <header class="header">
        <div class="header-inner">
            <div class="logo">
                <i class="fa-brands fa-js-square"></i>
                <span>JavaScript Guide</span>
            </div>
            <nav class="main-nav">
                <a href="#section-intro" class="nav-link active" data-section="intro">
                    <i class="fa-solid fa-door-open"></i> 시작
                </a>
                <a href="#section-basics" class="nav-link" data-section="basics">
                    <i class="fa-solid fa-cube"></i> 기초
                </a>
                <a href="#section-datatype" class="nav-link" data-section="datatype">
                    <i class="fa-solid fa-database"></i> 자료형
                </a>
                <a href="#section-operator" class="nav-link" data-section="operator">
                    <i class="fa-solid fa-calculator"></i> 연산자
                </a>
                <a href="#section-control" class="nav-link" data-section="control">
                    <i class="fa-solid fa-code-branch"></i> 제어문
                </a>
                <a href="#section-function" class="nav-link" data-section="function">
                    <i class="fa-solid fa-gear"></i> 함수
                </a>
                <a href="#section-array" class="nav-link" data-section="array">
                    <i class="fa-solid fa-layer-group"></i> 배열
                </a>
                <a href="#section-object" class="nav-link" data-section="object">
                    <i class="fa-solid fa-cube"></i> 객체
                </a>
                <a href="#section-dom" class="nav-link" data-section="dom">
                    <i class="fa-solid fa-sitemap"></i> DOM
                </a>
                <a href="#section-async" class="nav-link" data-section="async">
                    <i class="fa-solid fa-clock-rotate-left"></i> 비동기
                </a>
                <a href="#section-es6" class="nav-link" data-section="es6">
                    <i class="fa-solid fa-wand-magic-sparkles"></i> ES6+
                </a>
                <a href="#section-events" class="nav-link" data-section="events">
                    <i class="fa-solid fa-hand-pointer"></i> 이벤트
                </a>
            </nav>
            <button class="mobile-menu-btn">
                <i class="fa-solid fa-bars"></i>
            </button>
        </div>
    </header>

    <!-- 히어로 섹션 -->
    <section class="hero-section">
        <div class="hero-content">
            <h1 class="hero-title">JavaScript 완벽 가이드</h1>
            <p class="hero-subtitle">웹 개발의 핵심 언어, 자바스크립트의 모든 것</p>
            <div class="hero-tags">
                <span class="tag"><i class="fa-solid fa-code"></i> 프로그래밍 기초</span>
                <span class="tag"><i class="fa-solid fa-window-restore"></i> DOM 조작</span>
                <span class="tag"><i class="fa-solid fa-bolt"></i> 동적 웹 개발</span>
            </div>
        </div>
    </section>

    <!-- 퀵 네비게이션 슬라이더 -->
    <section class="quick-nav-section">
        <div class="swiper quick-nav-swiper">
            <div class="swiper-wrapper">
                <div class="swiper-slide">
                    <a href="#section-intro" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-door-open"></i></div>
                        <h3>JavaScript 소개</h3>
                        <p>역사와 특징, 실행 환경</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-basics" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-cube"></i></div>
                        <h3>기초 문법</h3>
                        <p>변수, 상수, 주석, 출력</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-datatype" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-database"></i></div>
                        <h3>자료형</h3>
                        <p>원시형과 참조형 이해</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-operator" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-calculator"></i></div>
                        <h3>연산자</h3>
                        <p>산술, 비교, 논리 연산자</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-control" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-code-branch"></i></div>
                        <h3>제어문</h3>
                        <p>조건문과 반복문</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-function" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-gear"></i></div>
                        <h3>함수</h3>
                        <p>선언, 표현식, 화살표 함수</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-array" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-layer-group"></i></div>
                        <h3>배열</h3>
                        <p>배열 메서드와 활용</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-object" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-cube"></i></div>
                        <h3>객체</h3>
                        <p>객체 생성과 프로퍼티</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-dom" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-sitemap"></i></div>
                        <h3>DOM</h3>
                        <p>문서 객체 모델 조작</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-async" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-clock-rotate-left"></i></div>
                        <h3>비동기</h3>
                        <p>Promise, async/await</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-es6" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-wand-magic-sparkles"></i></div>
                        <h3>ES6+</h3>
                        <p>모던 자바스크립트 문법</p>
                    </a>
                </div>
                <div class="swiper-slide">
                    <a href="#section-events" class="quick-card">
                        <div class="quick-icon"><i class="fa-solid fa-hand-pointer"></i></div>
                        <h3>이벤트 심화</h3>
                        <p>이벤트 전파와 위임</p>
                    </a>
                </div>
            </div>
            <div class="swiper-pagination"></div>
        </div>
    </section>

    <!-- 메인 콘텐츠 -->
    <main class="main-content">

        <!-- 섹션 1: JavaScript 소개 -->
        <section id="section-intro" class="content-section">
            <div class="section-header">
                <span class="section-number">01</span>
                <h2><i class="fa-solid fa-door-open"></i> JavaScript 소개</h2>
            </div>

            <div class="section-body">
                <!-- JavaScript란? -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-brands fa-js"></i></span>
                        JavaScript란?
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-question-circle"></i> 정의</h4>
                        <p>JavaScript는 웹 페이지에 <strong>동적인 기능</strong>을 추가하기 위해 만들어진 프로그래밍 언어이다. HTML은 구조를, CSS는 스타일을,
                            JavaScript는 <strong>동작</strong>을 담당한다.</p>
                        <p>현재는 웹 브라우저뿐만 아니라 서버(Node.js), 모바일 앱, 데스크톱 앱 등 다양한 환경에서 사용되는 범용 프로그래밍 언어로 발전했다.</p>
                    </div>

                    <div class="timeline-block">
                        <h4><i class="fa-solid fa-clock-rotate-left"></i> JavaScript의 역사</h4>
                        <div class="timeline">
                            <div class="timeline-item">
                                <div class="timeline-marker">
                                    <i class="fa-solid fa-star"></i>
                                </div>
                                <div class="timeline-content">
                                    <h5>1995년: 탄생</h5>
                                    <p>Netscape의 Brendan Eich가 단 10일 만에 개발. 처음에는 "Mocha"라고 불렸다가 "LiveScript"를 거쳐
                                        "JavaScript"로 명명되었다.</p>
                                </div>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-marker">
                                    <i class="fa-solid fa-balance-scale"></i>
                                </div>
                                <div class="timeline-content">
                                    <h5>1997년: ECMAScript 표준화</h5>
                                    <p>ECMA International에서 ECMAScript라는 이름으로 표준화. 브라우저 간 호환성 문제 해결의 시작.</p>
                                </div>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-marker">
                                    <i class="fa-solid fa-rocket"></i>
                                </div>
                                <div class="timeline-content">
                                    <h5>2009년: Node.js 등장</h5>
                                    <p>Ryan Dahl이 V8 엔진 기반의 Node.js를 발표. JavaScript가 서버 사이드에서도 사용 가능해짐.</p>
                                </div>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-marker">
                                    <i class="fa-solid fa-gem"></i>
                                </div>
                                <div class="timeline-content">
                                    <h5>2015년: ES6 (ES2015)</h5>
                                    <p>let, const, 화살표 함수, 클래스, 모듈 등 현대적 기능 대거 추가. JavaScript의 대변혁.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>JavaScript vs Java</h5>
                            <p>이름이 비슷하지만 <strong>완전히 다른 언어</strong>이다. JavaScript는 당시 인기 있던 Java의 이름을 마케팅 목적으로 빌려왔을 뿐,
                                문법이나 설계 철학이 전혀 다르다.</p>
                        </div>
                    </div>
                </article>

                <!-- JavaScript 특징 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-star"></i></span>
                        JavaScript의 특징
                    </h3>

                    <div class="feature-grid">
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fa-solid fa-feather"></i>
                            </div>
                            <h4>동적 타입 언어</h4>
                            <p>변수의 타입을 미리 선언하지 않아도 되며, 실행 중에 타입이 자동으로 결정된다.</p>
                            <div class="code-mini">
                                <code>let x = 10; // 숫자</code>
                                <code>x = "hello"; // 문자열로 변경 가능</code>
                            </div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fa-solid fa-puzzle-piece"></i>
                            </div>
                            <h4>객체 기반 언어</h4>
                            <p>거의 모든 것이 객체로 이루어져 있다. 함수도 객체, 배열도 객체이다.</p>
                            <div class="code-mini">
                                <code>const obj = { name: "Kim" };</code>
                                <code>const arr = [1, 2, 3]; // 배열도 객체</code>
                            </div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fa-solid fa-bolt"></i>
                            </div>
                            <h4>인터프리터 언어</h4>
                            <p>컴파일 과정 없이 코드를 한 줄씩 실행한다. 즉시 결과를 확인할 수 있다.</p>
                            <div class="code-mini">
                                <code>console.log("바로 실행!");</code>
                                <code>// 컴파일 필요 없음</code>
                            </div>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">
                                <i class="fa-solid fa-clock"></i>
                            </div>
                            <h4>비동기 처리</h4>
                            <p>시간이 걸리는 작업을 기다리지 않고 다음 코드를 실행할 수 있다.</p>
                            <div class="code-mini">
                                <code>setTimeout(() => {</code>
                                <code>  console.log("3초 후");</code>
                                <code>}, 3000);</code>
                            </div>
                        </div>
                    </div>
                </article>

                <!-- 실행 환경 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-play"></i></span>
                        JavaScript 실행 환경
                    </h3>

                    <div class="environment-cards">
                        <div class="env-card browser">
                            <div class="env-header">
                                <i class="fa-brands fa-chrome"></i>
                                <h4>브라우저</h4>
                            </div>
                            <div class="env-body">
                                <p>웹 브라우저에 내장된 JavaScript 엔진이 코드를 실행</p>
                                <ul>
                                    <li><strong>Chrome:</strong> V8 엔진</li>
                                    <li><strong>Firefox:</strong> SpiderMonkey</li>
                                    <li><strong>Safari:</strong> JavaScriptCore</li>
                                    <li><strong>Edge:</strong> V8 엔진</li>
                                </ul>
                                <div class="env-usage">
                                    <span class="label">용도</span>
                                    <span>웹 페이지 동작, DOM 조작, 이벤트 처리</span>
                                </div>
                            </div>
                        </div>
                        <div class="env-card nodejs">
                            <div class="env-header">
                                <i class="fa-brands fa-node-js"></i>
                                <h4>Node.js</h4>
                            </div>
                            <div class="env-body">
                                <p>V8 엔진을 기반으로 서버에서 JavaScript 실행 가능</p>
                                <ul>
                                    <li>서버 사이드 개발</li>
                                    <li>파일 시스템 접근</li>
                                    <li>데이터베이스 연동</li>
                                    <li>CLI 도구 개발</li>
                                </ul>
                                <div class="env-usage">
                                    <span class="label">용도</span>
                                    <span>백엔드 서버, API, 빌드 도구</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">HTML</span>
                            <span class="code-title">JavaScript 연결 방법</span>
                        </div>
                        <pre><code><span class="comment">&lt;!-- 1. 내부 스크립트 --&gt;</span>
<span class="tag">&lt;script&gt;</span>
    console.log("Hello, JavaScript!");
<span class="tag">&lt;/script&gt;</span>

<span class="comment">&lt;!-- 2. 외부 스크립트 (권장) --&gt;</span>
<span class="tag">&lt;script</span> <span class="attr">src</span>=<span class="string">"script.js"</span><span class="tag">&gt;&lt;/script&gt;</span>

<span class="comment">&lt;!-- 3. defer 속성 (HTML 파싱 후 실행) --&gt;</span>
<span class="tag">&lt;script</span> <span class="attr">src</span>=<span class="string">"script.js"</span> <span class="attr">defer</span><span class="tag">&gt;&lt;/script&gt;</span></code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 2: 기초 문법 -->
        <section id="section-basics" class="content-section">
            <div class="section-header">
                <span class="section-number">02</span>
                <h2><i class="fa-solid fa-cube"></i> 기초 문법</h2>
            </div>

            <div class="section-body">
                <!-- 변수와 상수 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-box"></i></span>
                        변수와 상수
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-box-open"></i> 변수란?</h4>
                        <p>변수는 데이터를 저장하는 <strong>이름 붙인 저장소</strong>이다. 프로그램 실행 중에 값을 저장하고, 필요할 때 꺼내 쓸 수 있다.</p>
                    </div>

                    <div class="compare-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>키워드</th>
                                    <th>재할당</th>
                                    <th>재선언</th>
                                    <th>스코프</th>
                                    <th>호이스팅</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="warning-row">
                                    <td><code>var</code></td>
                                    <td><i class="fa-solid fa-check text-success"></i> 가능</td>
                                    <td><i class="fa-solid fa-check text-success"></i> 가능</td>
                                    <td>함수 스코프</td>
                                    <td>undefined로 초기화</td>
                                </tr>
                                <tr class="success-row">
                                    <td><code>let</code></td>
                                    <td><i class="fa-solid fa-check text-success"></i> 가능</td>
                                    <td><i class="fa-solid fa-xmark text-danger"></i> 불가</td>
                                    <td>블록 스코프</td>
                                    <td>TDZ (일시적 사각지대)</td>
                                </tr>
                                <tr class="primary-row">
                                    <td><code>const</code></td>
                                    <td><i class="fa-solid fa-xmark text-danger"></i> 불가</td>
                                    <td><i class="fa-solid fa-xmark text-danger"></i> 불가</td>
                                    <td>블록 스코프</td>
                                    <td>TDZ (일시적 사각지대)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">변수 선언 예시</span>
                        </div>
                        <pre><code><span class="comment">// var - 옛날 방식 (사용 지양)</span>
<span class="keyword">var</span> oldWay = <span class="string">"피하세요"</span>;

<span class="comment">// let - 변경 가능한 변수</span>
<span class="keyword">let</span> count = <span class="number">0</span>;
count = <span class="number">1</span>;  <span class="comment">// 재할당 가능</span>

<span class="comment">// const - 상수 (변경 불가)</span>
<span class="keyword">const</span> PI = <span class="number">3.14159</span>;
<span class="comment">// PI = 3.14;  // Error! 재할당 불가</span>

<span class="comment">// const로 선언한 객체/배열의 내부는 변경 가능</span>
<span class="keyword">const</span> user = { name: <span class="string">"Kim"</span> };
user.name = <span class="string">"Lee"</span>;  <span class="comment">// 가능!</span>
<span class="comment">// user = {};  // Error! 참조 자체 변경 불가</span></code></pre>
                    </div>

                    <div class="highlight-box warning">
                        <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                        <div class="highlight-content">
                            <h5>var를 피해야 하는 이유</h5>
                            <p>var는 함수 스코프만 인식하여 블록 밖에서도 접근 가능하고, 재선언이 가능해 버그 발생 위험이 높다. <strong>항상 const를 기본으로
                                    사용</strong>하고, 재할당이 필요한 경우에만 let을 사용한다.</p>
                        </div>
                    </div>
                </article>

                <!-- 변수 명명 규칙 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-tag"></i></span>
                        변수 명명 규칙
                    </h3>

                    <div class="rule-grid">
                        <div class="rule-card allowed">
                            <div class="rule-header">
                                <i class="fa-solid fa-check-circle"></i>
                                <h4>사용 가능</h4>
                            </div>
                            <ul>
                                <li>문자, 숫자, _, $ 사용 가능</li>
                                <li>첫 글자는 문자, _, $로 시작</li>
                                <li>대소문자 구분</li>
                                <li>유니코드 문자 사용 가능</li>
                            </ul>
                            <div class="rule-examples">
                                <code>userName</code>
                                <code>_private</code>
                                <code>$element</code>
                                <code>count1</code>
                            </div>
                        </div>
                        <div class="rule-card forbidden">
                            <div class="rule-header">
                                <i class="fa-solid fa-xmark-circle"></i>
                                <h4>사용 불가</h4>
                            </div>
                            <ul>
                                <li>숫자로 시작</li>
                                <li>예약어 사용</li>
                                <li>특수문자 (_, $ 제외)</li>
                                <li>공백 포함</li>
                            </ul>
                            <div class="rule-examples forbidden">
                                <code>1stPlace</code>
                                <code>let</code>
                                <code>user-name</code>
                                <code>my var</code>
                            </div>
                        </div>
                    </div>

                    <div class="naming-conventions">
                        <h4><i class="fa-solid fa-pen-nib"></i> 명명 컨벤션</h4>
                        <div class="convention-grid">
                            <div class="convention-item">
                                <span class="convention-name">camelCase</span>
                                <span class="convention-use">변수, 함수</span>
                                <code>userName, getUserData</code>
                            </div>
                            <div class="convention-item">
                                <span class="convention-name">PascalCase</span>
                                <span class="convention-use">클래스, 생성자</span>
                                <code>UserProfile, DataManager</code>
                            </div>
                            <div class="convention-item">
                                <span class="convention-name">UPPER_SNAKE_CASE</span>
                                <span class="convention-use">상수</span>
                                <code>MAX_SIZE, API_KEY</code>
                            </div>
                        </div>
                    </div>
                </article>

                <!-- 출력과 주석 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-terminal"></i></span>
                        출력과 주석
                    </h3>

                    <div class="output-methods">
                        <h4><i class="fa-solid fa-display"></i> 출력 방법</h4>
                        <div class="method-cards">
                            <div class="method-card">
                                <h5>console.log()</h5>
                                <p>개발자 도구 콘솔에 출력 (디버깅용)</p>
                                <code>console.log("Hello");</code>
                            </div>
                            <div class="method-card">
                                <h5>alert()</h5>
                                <p>브라우저 알림창 표시</p>
                                <code>alert("경고!");</code>
                            </div>
                            <div class="method-card">
                                <h5>document.write()</h5>
                                <p>HTML 문서에 직접 출력 (비권장)</p>
                                <code>document.write("텍스트");</code>
                            </div>
                            <div class="method-card">
                                <h5>innerHTML</h5>
                                <p>HTML 요소의 내용 변경</p>
                                <code>el.innerHTML = "내용";</code>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">주석 작성법</span>
                        </div>
                        <pre><code><span class="comment">// 한 줄 주석: 간단한 설명에 사용</span>

<span class="comment">/*
  여러 줄 주석
  긴 설명이나 코드 블록을
  임시로 비활성화할 때 사용
*/</span>

<span class="comment">/**
 * JSDoc 주석 (문서화용)
 * @param {string} name - 사용자 이름
 * @returns {string} 인사말
 */</span>
<span class="keyword">function</span> <span class="function">greet</span>(name) {
    <span class="keyword">return</span> <span class="string">`안녕하세요, </span><span class="interpolation">${name}</span><span class="string">님!`</span>;
}</code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 3: 자료형 -->
        <section id="section-datatype" class="content-section">
            <div class="section-header">
                <span class="section-number">03</span>
                <h2><i class="fa-solid fa-database"></i> 자료형 (Data Types)</h2>
            </div>

            <div class="section-body">
                <!-- 원시 타입 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-atom"></i></span>
                        원시 타입 (Primitive Types)
                    </h3>

                    <div class="content-card">
                        <p>원시 타입은 <strong>불변(immutable)</strong>한 값으로, 변수에 직접 값이 저장된다. JavaScript에는 7가지 원시 타입이 있다.</p>
                    </div>

                    <div class="type-cards">
                        <div class="type-card">
                            <div class="type-header number">
                                <span class="type-name">Number</span>
                            </div>
                            <div class="type-body">
                                <p>정수와 실수를 모두 포함하는 숫자 타입</p>
                                <div class="type-examples">
                                    <code>42</code>
                                    <code>3.14</code>
                                    <code>-10</code>
                                    <code>Infinity</code>
                                    <code>NaN</code>
                                </div>
                            </div>
                        </div>
                        <div class="type-card">
                            <div class="type-header string">
                                <span class="type-name">String</span>
                            </div>
                            <div class="type-body">
                                <p>문자의 집합, 텍스트 데이터</p>
                                <div class="type-examples">
                                    <code>"Hello"</code>
                                    <code>'World'</code>
                                    <code>`템플릿`</code>
                                </div>
                            </div>
                        </div>
                        <div class="type-card">
                            <div class="type-header boolean">
                                <span class="type-name">Boolean</span>
                            </div>
                            <div class="type-body">
                                <p>참/거짓을 나타내는 논리 타입</p>
                                <div class="type-examples">
                                    <code>true</code>
                                    <code>false</code>
                                </div>
                            </div>
                        </div>
                        <div class="type-card">
                            <div class="type-header undefined">
                                <span class="type-name">Undefined</span>
                            </div>
                            <div class="type-body">
                                <p>값이 할당되지 않은 상태</p>
                                <div class="type-examples">
                                    <code>undefined</code>
                                </div>
                            </div>
                        </div>
                        <div class="type-card">
                            <div class="type-header null">
                                <span class="type-name">Null</span>
                            </div>
                            <div class="type-body">
                                <p>의도적으로 비어있음을 나타냄</p>
                                <div class="type-examples">
                                    <code>null</code>
                                </div>
                            </div>
                        </div>
                        <div class="type-card">
                            <div class="type-header symbol">
                                <span class="type-name">Symbol</span>
                            </div>
                            <div class="type-body">
                                <p>고유하고 변경 불가능한 값 (ES6+)</p>
                                <div class="type-examples">
                                    <code>Symbol("id")</code>
                                </div>
                            </div>
                        </div>
                        <div class="type-card">
                            <div class="type-header bigint">
                                <span class="type-name">BigInt</span>
                            </div>
                            <div class="type-body">
                                <p>아주 큰 정수를 표현 (ES2020+)</p>
                                <div class="type-examples">
                                    <code>9007199254740991n</code>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">typeof 연산자로 타입 확인</span>
                        </div>
                        <pre><code><span class="keyword">typeof</span> <span class="number">42</span>;          <span class="comment">// "number"</span>
<span class="keyword">typeof</span> <span class="string">"hello"</span>;     <span class="comment">// "string"</span>
<span class="keyword">typeof</span> <span class="boolean">true</span>;        <span class="comment">// "boolean"</span>
<span class="keyword">typeof</span> <span class="keyword">undefined</span>;   <span class="comment">// "undefined"</span>
<span class="keyword">typeof</span> <span class="keyword">null</span>;        <span class="comment">// "object" (버그, 하위 호환성 유지)</span>
<span class="keyword">typeof</span> Symbol();    <span class="comment">// "symbol"</span>
<span class="keyword">typeof</span> <span class="number">10n</span>;         <span class="comment">// "bigint"</span></code></pre>
                    </div>
                </article>

                <!-- 참조 타입 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-link"></i></span>
                        참조 타입 (Reference Types)
                    </h3>

                    <div class="content-card">
                        <p>참조 타입은 <strong>메모리 주소</strong>를 저장한다. 변수에는 실제 값이 아닌 값이 저장된 위치(참조)가 담긴다.</p>
                    </div>

                    <div class="reference-compare">
                        <div class="compare-item primitive">
                            <h4><i class="fa-solid fa-cube"></i> 원시 타입</h4>
                            <div class="compare-visual">
                                <div class="memory-box">
                                    <span class="var-name">a</span>
                                    <span class="var-value">10</span>
                                </div>
                                <div class="memory-box">
                                    <span class="var-name">b</span>
                                    <span class="var-value">10</span>
                                </div>
                            </div>
                            <p>값 자체가 복사됨 (독립적)</p>
                        </div>
                        <div class="compare-item reference">
                            <h4><i class="fa-solid fa-link"></i> 참조 타입</h4>
                            <div class="compare-visual">
                                <div class="memory-box">
                                    <span class="var-name">a</span>
                                    <span class="var-value ref">0x001</span>
                                </div>
                                <div class="memory-box">
                                    <span class="var-name">b</span>
                                    <span class="var-value ref">0x001</span>
                                </div>
                                <div class="memory-target">
                                    <span>{...}</span>
                                </div>
                            </div>
                            <p>주소가 복사됨 (같은 객체 참조)</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">참조 타입 예시</span>
                        </div>
                        <pre><code><span class="comment">// 객체 (Object)</span>
<span class="keyword">const</span> person = {
    name: <span class="string">"Kim"</span>,
    age: <span class="number">25</span>
};

<span class="comment">// 배열 (Array)</span>
<span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="comment">// 함수 (Function)</span>
<span class="keyword">const</span> greet = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="string">"Hello!"</span>;
};

<span class="comment">// 참조 복사 예시</span>
<span class="keyword">const</span> original = { value: <span class="number">10</span> };
<span class="keyword">const</span> copy = original;  <span class="comment">// 같은 객체 참조</span>
copy.value = <span class="number">20</span>;
console.log(original.value);  <span class="comment">// 20 (원본도 변경됨!)</span></code></pre>
                    </div>
                </article>

                <!-- 형 변환 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-exchange-alt"></i></span>
                        형 변환 (Type Conversion)
                    </h3>

                    <div class="conversion-grid">
                        <div class="conversion-card">
                            <h4>문자열로 변환</h4>
                            <div class="conversion-methods">
                                <code>String(123)</code>
                                <code>(123).toString()</code>
                                <code>123 + ""</code>
                            </div>
                        </div>
                        <div class="conversion-card">
                            <h4>숫자로 변환</h4>
                            <div class="conversion-methods">
                                <code>Number("123")</code>
                                <code>parseInt("123")</code>
                                <code>parseFloat("3.14")</code>
                                <code>+"123"</code>
                            </div>
                        </div>
                        <div class="conversion-card">
                            <h4>불리언으로 변환</h4>
                            <div class="conversion-methods">
                                <code>Boolean(1)</code>
                                <code>!!value</code>
                            </div>
                        </div>
                    </div>

                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>Falsy 값들</h5>
                            <p>Boolean으로 변환 시 <strong>false</strong>가 되는 값들:</p>
                            <div class="falsy-values">
                                <code>false</code>
                                <code>0</code>
                                <code>-0</code>
                                <code>""</code>
                                <code>null</code>
                                <code>undefined</code>
                                <code>NaN</code>
                            </div>
                            <p>이 외의 모든 값은 <strong>truthy</strong> (true로 변환)</p>
                        </div>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 4: 연산자 -->
        <section id="section-operator" class="content-section">
            <div class="section-header">
                <span class="section-number">04</span>
                <h2><i class="fa-solid fa-calculator"></i> 연산자 (Operators)</h2>
            </div>

            <div class="section-body">
                <!-- 산술 연산자 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-plus-minus"></i></span>
                        산술 연산자
                    </h3>

                    <div class="operator-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>연산자</th>
                                    <th>설명</th>
                                    <th>예시</th>
                                    <th>결과</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>+</code></td>
                                    <td>덧셈</td>
                                    <td>5 + 3</td>
                                    <td>8</td>
                                </tr>
                                <tr>
                                    <td><code>-</code></td>
                                    <td>뺄셈</td>
                                    <td>5 - 3</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td><code>*</code></td>
                                    <td>곱셈</td>
                                    <td>5 * 3</td>
                                    <td>15</td>
                                </tr>
                                <tr>
                                    <td><code>/</code></td>
                                    <td>나눗셈</td>
                                    <td>5 / 2</td>
                                    <td>2.5</td>
                                </tr>
                                <tr>
                                    <td><code>%</code></td>
                                    <td>나머지</td>
                                    <td>5 % 2</td>
                                    <td>1</td>
                                </tr>
                                <tr>
                                    <td><code>**</code></td>
                                    <td>거듭제곱</td>
                                    <td>2 ** 3</td>
                                    <td>8</td>
                                </tr>
                                <tr>
                                    <td><code>++</code></td>
                                    <td>증가</td>
                                    <td>x++ / ++x</td>
                                    <td>x + 1</td>
                                </tr>
                                <tr>
                                    <td><code>--</code></td>
                                    <td>감소</td>
                                    <td>x-- / --x</td>
                                    <td>x - 1</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <!-- 비교 연산자 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-not-equal"></i></span>
                        비교 연산자
                    </h3>

                    <div class="operator-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>연산자</th>
                                    <th>설명</th>
                                    <th>예시</th>
                                    <th>결과</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>==</code></td>
                                    <td>동등 (값만 비교)</td>
                                    <td>"5" == 5</td>
                                    <td>true</td>
                                </tr>
                                <tr class="highlight">
                                    <td><code>===</code></td>
                                    <td>일치 (값 + 타입)</td>
                                    <td>"5" === 5</td>
                                    <td>false</td>
                                </tr>
                                <tr>
                                    <td><code>!=</code></td>
                                    <td>부등 (값만 비교)</td>
                                    <td>"5" != 5</td>
                                    <td>false</td>
                                </tr>
                                <tr class="highlight">
                                    <td><code>!==</code></td>
                                    <td>불일치 (값 + 타입)</td>
                                    <td>"5" !== 5</td>
                                    <td>true</td>
                                </tr>
                                <tr>
                                    <td><code>&gt;</code></td>
                                    <td>크다</td>
                                    <td>5 &gt; 3</td>
                                    <td>true</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;</code></td>
                                    <td>작다</td>
                                    <td>5 &lt; 3</td>
                                    <td>false</td>
                                </tr>
                                <tr>
                                    <td><code>&gt;=</code></td>
                                    <td>크거나 같다</td>
                                    <td>5 &gt;= 5</td>
                                    <td>true</td>
                                </tr>
                                <tr>
                                    <td><code>&lt;=</code></td>
                                    <td>작거나 같다</td>
                                    <td>5 &lt;= 3</td>
                                    <td>false</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="highlight-box warning">
                        <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                        <div class="highlight-content">
                            <h5>항상 === 와 !== 를 사용하라</h5>
                            <p>== 와 != 는 암묵적 형 변환을 수행하여 예상치 못한 결과를 낳을 수 있다. <strong>엄격한 비교(===, !==)</strong>를 사용하면 타입까지
                                비교하여 버그를 예방할 수 있다.</p>
                        </div>
                    </div>
                </article>

                <!-- 논리 연산자 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-code-branch"></i></span>
                        논리 연산자
                    </h3>

                    <div class="logic-grid">
                        <div class="logic-card">
                            <div class="logic-header">
                                <code>&&</code>
                                <span>AND (논리곱)</span>
                            </div>
                            <p>모두 true일 때만 true</p>
                            <div class="logic-table">
                                <div class="logic-row">
                                    <span>true && true</span>
                                    <span class="result true">true</span>
                                </div>
                                <div class="logic-row">
                                    <span>true && false</span>
                                    <span class="result false">false</span>
                                </div>
                            </div>
                        </div>
                        <div class="logic-card">
                            <div class="logic-header">
                                <code>||</code>
                                <span>OR (논리합)</span>
                            </div>
                            <p>하나라도 true면 true</p>
                            <div class="logic-table">
                                <div class="logic-row">
                                    <span>true || false</span>
                                    <span class="result true">true</span>
                                </div>
                                <div class="logic-row">
                                    <span>false || false</span>
                                    <span class="result false">false</span>
                                </div>
                            </div>
                        </div>
                        <div class="logic-card">
                            <div class="logic-header">
                                <code>!</code>
                                <span>NOT (부정)</span>
                            </div>
                            <p>true/false 반전</p>
                            <div class="logic-table">
                                <div class="logic-row">
                                    <span>!true</span>
                                    <span class="result false">false</span>
                                </div>
                                <div class="logic-row">
                                    <span>!false</span>
                                    <span class="result true">true</span>
                                </div>
                            </div>
                        </div>
                        <div class="logic-card">
                            <div class="logic-header">
                                <code>??</code>
                                <span>Nullish 병합</span>
                            </div>
                            <p>null/undefined일 때만 대체</p>
                            <div class="logic-table">
                                <div class="logic-row">
                                    <span>null ?? "기본값"</span>
                                    <span class="result string">"기본값"</span>
                                </div>
                                <div class="logic-row">
                                    <span>0 ?? "기본값"</span>
                                    <span class="result number">0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">단축 평가 활용</span>
                        </div>
                        <pre><code><span class="comment">// && : 첫 번째 falsy 값 또는 마지막 값 반환</span>
<span class="keyword">const</span> result1 = <span class="string">"hello"</span> && <span class="number">123</span>;  <span class="comment">// 123</span>
<span class="keyword">const</span> result2 = <span class="number">0</span> && <span class="string">"hello"</span>;     <span class="comment">// 0</span>

<span class="comment">// || : 첫 번째 truthy 값 또는 마지막 값 반환</span>
<span class="keyword">const</span> name = userInput || <span class="string">"Guest"</span>;  <span class="comment">// 기본값 설정</span>

<span class="comment">// ?? : null이나 undefined만 체크 (0, ""는 유효)</span>
<span class="keyword">const</span> count = userCount ?? <span class="number">0</span>;  <span class="comment">// null/undefined면 0</span>

<span class="comment">// 조건부 실행</span>
isLoggedIn && showDashboard();  <span class="comment">// 로그인 시에만 실행</span></code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 5: 제어문 -->
        <section id="section-control" class="content-section">
            <div class="section-header">
                <span class="section-number">05</span>
                <h2><i class="fa-solid fa-code-branch"></i> 제어문</h2>
            </div>

            <div class="section-body">
                <!-- 조건문 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-question"></i></span>
                        조건문 (Conditional Statements)
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">if...else 문</span>
                        </div>
                        <pre><code><span class="keyword">const</span> score = <span class="number">85</span>;

<span class="keyword">if</span> (score >= <span class="number">90</span>) {
    console.log(<span class="string">"A 학점"</span>);
} <span class="keyword">else if</span> (score >= <span class="number">80</span>) {
    console.log(<span class="string">"B 학점"</span>);
} <span class="keyword">else if</span> (score >= <span class="number">70</span>) {
    console.log(<span class="string">"C 학점"</span>);
} <span class="keyword">else</span> {
    console.log(<span class="string">"F 학점"</span>);
}

<span class="comment">// 삼항 연산자 (간단한 조건)</span>
<span class="keyword">const</span> result = score >= <span class="number">60</span> ? <span class="string">"합격"</span> : <span class="string">"불합격"</span>;</code></pre>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">switch 문</span>
                        </div>
                        <pre><code><span class="keyword">const</span> day = <span class="number">3</span>;

<span class="keyword">switch</span> (day) {
    <span class="keyword">case</span> <span class="number">1</span>:
        console.log(<span class="string">"월요일"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">2</span>:
        console.log(<span class="string">"화요일"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">3</span>:
        console.log(<span class="string">"수요일"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">default</span>:
        console.log(<span class="string">"기타"</span>);
}</code></pre>
                    </div>
                </article>

                <!-- 반복문 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-repeat"></i></span>
                        반복문 (Loops)
                    </h3>

                    <div class="loop-cards">
                        <div class="loop-card">
                            <h4>for 문</h4>
                            <p>횟수가 정해진 반복</p>
                            <pre><code><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) {
    console.log(i);
}</code></pre>
                        </div>
                        <div class="loop-card">
                            <h4>while 문</h4>
                            <p>조건이 참인 동안 반복</p>
                            <pre><code><span class="keyword">let</span> i = <span class="number">0</span>;
<span class="keyword">while</span> (i < <span class="number">5</span>) {
    console.log(i);
    i++;
}</code></pre>
                        </div>
                        <div class="loop-card">
                            <h4>do...while 문</h4>
                            <p>최소 1회 실행 보장</p>
                            <pre><code><span class="keyword">let</span> i = <span class="number">0</span>;
<span class="keyword">do</span> {
    console.log(i);
    i++;
} <span class="keyword">while</span> (i < <span class="number">5</span>);</code></pre>
                        </div>
                        <div class="loop-card">
                            <h4>for...of 문</h4>
                            <p>이터러블 순회 (배열, 문자열)</p>
                            <pre><code><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) {
    console.log(item);
}</code></pre>
                        </div>
                        <div class="loop-card">
                            <h4>for...in 문</h4>
                            <p>객체의 키 순회</p>
                            <pre><code><span class="keyword">const</span> obj = {a: <span class="number">1</span>, b: <span class="number">2</span>};
<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) {
    console.log(key, obj[key]);
}</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>break와 continue</h5>
                            <p><strong>break</strong>: 반복문을 즉시 종료<br>
                                <strong>continue</strong>: 현재 반복을 건너뛰고 다음 반복으로
                            </p>
                        </div>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 6: 함수 -->
        <section id="section-function" class="content-section">
            <div class="section-header">
                <span class="section-number">06</span>
                <h2><i class="fa-solid fa-gear"></i> 함수 (Functions)</h2>
            </div>

            <div class="section-body">
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-code"></i></span>
                        함수 선언 방식
                    </h3>

                    <div class="function-types">
                        <div class="function-type">
                            <h4>함수 선언문</h4>
                            <p>호이스팅 됨 (선언 전에 호출 가능)</p>
                            <pre><code><span class="keyword">function</span> <span class="function">greet</span>(name) {
    <span class="keyword">return</span> <span class="string">`안녕, </span><span class="interpolation">${name}</span><span class="string">!`</span>;
}</code></pre>
                        </div>
                        <div class="function-type">
                            <h4>함수 표현식</h4>
                            <p>변수에 함수 할당</p>
                            <pre><code><span class="keyword">const</span> greet = <span class="keyword">function</span>(name) {
    <span class="keyword">return</span> <span class="string">`안녕, </span><span class="interpolation">${name}</span><span class="string">!`</span>;
};</code></pre>
                        </div>
                        <div class="function-type highlight">
                            <h4>화살표 함수 (ES6+)</h4>
                            <p>간결한 문법, this 바인딩 차이</p>
                            <pre><code><span class="keyword">const</span> greet = (name) => <span class="string">`안녕, </span><span class="interpolation">${name}</span><span class="string">!`</span>;

<span class="comment">// 매개변수가 하나면 괄호 생략 가능</span>
<span class="keyword">const</span> double = x => x * <span class="number">2</span>;

<span class="comment">// 본문이 여러 줄이면 중괄호 필요</span>
<span class="keyword">const</span> add = (a, b) => {
    <span class="keyword">const</span> sum = a + b;
    <span class="keyword">return</span> sum;
};</code></pre>
                        </div>
                    </div>
                </article>

                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-sliders"></i></span>
                        매개변수와 반환값
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">매개변수 활용</span>
                        </div>
                        <pre><code><span class="comment">// 기본값 매개변수</span>
<span class="keyword">function</span> <span class="function">greet</span>(name = <span class="string">"Guest"</span>) {
    <span class="keyword">return</span> <span class="string">`Hello, </span><span class="interpolation">${name}</span><span class="string">!`</span>;
}

<span class="comment">// 나머지 매개변수 (Rest Parameters)</span>
<span class="keyword">function</span> <span class="function">sum</span>(...numbers) {
    <span class="keyword">return</span> numbers.reduce((a, b) => a + b, <span class="number">0</span>);
}
sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 10</span>

<span class="comment">// 구조 분해 매개변수</span>
<span class="keyword">function</span> <span class="function">printUser</span>({ name, age }) {
    console.log(<span class="string">`</span><span class="interpolation">${name}</span><span class="string">님은 </span><span class="interpolation">${age}</span><span class="string">세입니다.`</span>);
}
printUser({ name: <span class="string">"Kim"</span>, age: <span class="number">25</span> });</code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 7: 배열 -->
        <section id="section-array" class="content-section">
            <div class="section-header">
                <span class="section-number">07</span>
                <h2><i class="fa-solid fa-layer-group"></i> 배열 (Arrays)</h2>
            </div>

            <div class="section-body">
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-list"></i></span>
                        배열 기초
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">배열 생성과 접근</span>
                        </div>
                        <pre><code><span class="comment">// 배열 생성</span>
<span class="keyword">const</span> fruits = [<span class="string">"사과"</span>, <span class="string">"바나나"</span>, <span class="string">"오렌지"</span>];
<span class="keyword">const</span> numbers = <span class="keyword">new</span> Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);

<span class="comment">// 인덱스로 접근 (0부터 시작)</span>
console.log(fruits[<span class="number">0</span>]);  <span class="comment">// "사과"</span>
console.log(fruits[<span class="number">2</span>]);  <span class="comment">// "오렌지"</span>

<span class="comment">// 길이</span>
console.log(fruits.length);  <span class="comment">// 3</span>

<span class="comment">// 요소 수정</span>
fruits[<span class="number">1</span>] = <span class="string">"포도"</span>;</code></pre>
                    </div>
                </article>

                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                        주요 배열 메서드
                    </h3>

                    <div class="method-grid">
                        <div class="method-category">
                            <h4><i class="fa-solid fa-plus"></i> 추가/제거</h4>
                            <div class="method-list">
                                <div class="method-item">
                                    <code>push()</code>
                                    <span>끝에 추가</span>
                                </div>
                                <div class="method-item">
                                    <code>pop()</code>
                                    <span>끝에서 제거</span>
                                </div>
                                <div class="method-item">
                                    <code>unshift()</code>
                                    <span>앞에 추가</span>
                                </div>
                                <div class="method-item">
                                    <code>shift()</code>
                                    <span>앞에서 제거</span>
                                </div>
                                <div class="method-item">
                                    <code>splice()</code>
                                    <span>특정 위치 추가/제거</span>
                                </div>
                            </div>
                        </div>
                        <div class="method-category">
                            <h4><i class="fa-solid fa-magnifying-glass"></i> 검색</h4>
                            <div class="method-list">
                                <div class="method-item">
                                    <code>indexOf()</code>
                                    <span>인덱스 찾기</span>
                                </div>
                                <div class="method-item">
                                    <code>includes()</code>
                                    <span>포함 여부</span>
                                </div>
                                <div class="method-item">
                                    <code>find()</code>
                                    <span>조건에 맞는 첫 요소</span>
                                </div>
                                <div class="method-item">
                                    <code>findIndex()</code>
                                    <span>조건에 맞는 인덱스</span>
                                </div>
                            </div>
                        </div>
                        <div class="method-category">
                            <h4><i class="fa-solid fa-arrows-rotate"></i> 변환</h4>
                            <div class="method-list">
                                <div class="method-item">
                                    <code>map()</code>
                                    <span>각 요소 변환</span>
                                </div>
                                <div class="method-item">
                                    <code>filter()</code>
                                    <span>조건으로 필터링</span>
                                </div>
                                <div class="method-item">
                                    <code>reduce()</code>
                                    <span>누적 계산</span>
                                </div>
                                <div class="method-item">
                                    <code>sort()</code>
                                    <span>정렬</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">고차 함수 활용</span>
                        </div>
                        <pre><code><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="comment">// map: 각 요소를 2배로</span>
<span class="keyword">const</span> doubled = numbers.map(n => n * <span class="number">2</span>);
<span class="comment">// [2, 4, 6, 8, 10]</span>

<span class="comment">// filter: 짝수만 필터링</span>
<span class="keyword">const</span> evens = numbers.filter(n => n % <span class="number">2</span> === <span class="number">0</span>);
<span class="comment">// [2, 4]</span>

<span class="comment">// reduce: 합계 계산</span>
<span class="keyword">const</span> sum = numbers.reduce((acc, n) => acc + n, <span class="number">0</span>);
<span class="comment">// 15</span>

<span class="comment">// 메서드 체이닝</span>
<span class="keyword">const</span> result = numbers
    .filter(n => n > <span class="number">2</span>)
    .map(n => n * <span class="number">2</span>)
    .reduce((a, b) => a + b);
<span class="comment">// (3+4+5) * 2 각각 = 6+8+10 = 24</span></code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 8: 객체 -->
        <section id="section-object" class="content-section">
            <div class="section-header">
                <span class="section-number">08</span>
                <h2><i class="fa-solid fa-cube"></i> 객체 (Objects)</h2>
            </div>

            <div class="section-body">
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-cubes"></i></span>
                        객체 기초
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">객체 생성과 접근</span>
                        </div>
                        <pre><code><span class="comment">// 객체 리터럴</span>
<span class="keyword">const</span> user = {
    name: <span class="string">"Kim"</span>,
    age: <span class="number">25</span>,
    isAdmin: <span class="boolean">false</span>,
    greet() {
        <span class="keyword">return</span> <span class="string">`안녕하세요, </span><span class="interpolation">${this.name}</span><span class="string">입니다!`</span>;
    }
};

<span class="comment">// 프로퍼티 접근</span>
console.log(user.name);       <span class="comment">// 점 표기법</span>
console.log(user[<span class="string">"age"</span>]);    <span class="comment">// 대괄호 표기법</span>

<span class="comment">// 메서드 호출</span>
console.log(user.greet());

<span class="comment">// 프로퍼티 추가/수정/삭제</span>
user.email = <span class="string">"kim@example.com"</span>;  <span class="comment">// 추가</span>
user.age = <span class="number">26</span>;                    <span class="comment">// 수정</span>
<span class="keyword">delete</span> user.isAdmin;              <span class="comment">// 삭제</span></code></pre>
                    </div>
                </article>

                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-expand"></i></span>
                        구조 분해 할당
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">Destructuring</span>
                        </div>
                        <pre><code><span class="keyword">const</span> user = { name: <span class="string">"Kim"</span>, age: <span class="number">25</span>, city: <span class="string">"Seoul"</span> };

<span class="comment">// 객체 구조 분해</span>
<span class="keyword">const</span> { name, age } = user;
console.log(name, age);  <span class="comment">// "Kim" 25</span>

<span class="comment">// 새 변수명으로 할당</span>
<span class="keyword">const</span> { name: userName } = user;
console.log(userName);  <span class="comment">// "Kim"</span>

<span class="comment">// 기본값 설정</span>
<span class="keyword">const</span> { country = <span class="string">"Korea"</span> } = user;

<span class="comment">// 배열 구조 분해</span>
<span class="keyword">const</span> [first, second, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
console.log(first, second, rest);  <span class="comment">// 1 2 [3, 4, 5]</span></code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 9: DOM -->
        <section id="section-dom" class="content-section">
            <div class="section-header">
                <span class="section-number">09</span>
                <h2><i class="fa-solid fa-sitemap"></i> DOM 조작</h2>
            </div>

            <div class="section-body">
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-hand-pointer"></i></span>
                        요소 선택
                    </h3>

                    <div class="dom-methods">
                        <div class="dom-method">
                            <code>document.getElementById('id')</code>
                            <span>ID로 단일 요소 선택</span>
                        </div>
                        <div class="dom-method">
                            <code>document.querySelector('selector')</code>
                            <span>CSS 선택자로 첫 요소</span>
                        </div>
                        <div class="dom-method">
                            <code>document.querySelectorAll('selector')</code>
                            <span>CSS 선택자로 모든 요소</span>
                        </div>
                        <div class="dom-method">
                            <code>document.getElementsByClassName('class')</code>
                            <span>클래스명으로 선택</span>
                        </div>
                        <div class="dom-method">
                            <code>document.getElementsByTagName('tag')</code>
                            <span>태그명으로 선택</span>
                        </div>
                    </div>
                </article>

                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-pen"></i></span>
                        요소 조작
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">DOM 조작 예시</span>
                        </div>
                        <pre><code><span class="keyword">const</span> el = document.querySelector(<span class="string">'.my-element'</span>);

<span class="comment">// 내용 변경</span>
el.textContent = <span class="string">"새로운 텍스트"</span>;
el.innerHTML = <span class="string">"&lt;strong&gt;HTML&lt;/strong&gt; 가능"</span>;

<span class="comment">// 스타일 변경</span>
el.style.color = <span class="string">"red"</span>;
el.style.backgroundColor = <span class="string">"#f0f0f0"</span>;

<span class="comment">// 클래스 조작</span>
el.classList.add(<span class="string">"active"</span>);
el.classList.remove(<span class="string">"hidden"</span>);
el.classList.toggle(<span class="string">"visible"</span>);
el.classList.contains(<span class="string">"active"</span>);  <span class="comment">// true/false</span>

<span class="comment">// 속성 조작</span>
el.setAttribute(<span class="string">"data-id"</span>, <span class="string">"123"</span>);
el.getAttribute(<span class="string">"href"</span>);
el.removeAttribute(<span class="string">"disabled"</span>);</code></pre>
                    </div>
                </article>

                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-bolt"></i></span>
                        이벤트 처리
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">이벤트 리스너</span>
                        </div>
                        <pre><code><span class="keyword">const</span> button = document.querySelector(<span class="string">'button'</span>);

<span class="comment">// 이벤트 리스너 추가</span>
button.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>(event) {
    console.log(<span class="string">'버튼 클릭!'</span>);
    console.log(event.target);  <span class="comment">// 클릭된 요소</span>
});

<span class="comment">// 화살표 함수로</span>
button.addEventListener(<span class="string">'click'</span>, (e) => {
    e.preventDefault();  <span class="comment">// 기본 동작 방지</span>
});

<span class="comment">// 자주 사용하는 이벤트</span>
<span class="comment">// click, dblclick, mouseenter, mouseleave</span>
<span class="comment">// keydown, keyup, keypress</span>
<span class="comment">// submit, change, input, focus, blur</span>
<span class="comment">// scroll, resize, load, DOMContentLoaded</span></code></pre>
                    </div>

                </article>
            </div>
        </section>

        <!-- 섹션 10: 비동기 프로그래밍 -->
        <section id="section-async" class="content-section">
            <div class="section-header">
                <span class="section-number">10</span>
                <h2><i class="fa-solid fa-clock"></i> 비동기 프로그래밍</h2>
            </div>

            <div class="section-body">
                <!-- 비동기란? -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-hourglass-half"></i></span>
                        동기 vs 비동기
                    </h3>

                    <div class="sync-async-compare">
                        <div class="compare-card sync">
                            <div class="compare-header">
                                <i class="fa-solid fa-arrow-down-long"></i>
                                <h4>동기 (Synchronous)</h4>
                            </div>
                            <div class="compare-body">
                                <p>코드가 <strong>순서대로</strong> 실행되고, 앞의 작업이 끝나야 다음 작업 시작</p>
                                <div class="flow-visual">
                                    <div class="flow-step">작업 1</div>
                                    <div class="flow-arrow"><i class="fa-solid fa-arrow-down"></i></div>
                                    <div class="flow-step waiting">대기...</div>
                                    <div class="flow-arrow"><i class="fa-solid fa-arrow-down"></i></div>
                                    <div class="flow-step">작업 2</div>
                                </div>
                                <p class="compare-desc">커피숍에서 앞 사람 주문이 나올 때까지 기다리는 것</p>
                            </div>
                        </div>
                        <div class="compare-card async">
                            <div class="compare-header">
                                <i class="fa-solid fa-arrows-split-up-and-left"></i>
                                <h4>비동기 (Asynchronous)</h4>
                            </div>
                            <div class="compare-body">
                                <p>오래 걸리는 작업은 <strong>백그라운드</strong>에서 처리하고 다음 코드 실행</p>
                                <div class="flow-visual async">
                                    <div class="flow-step">작업 1 시작</div>
                                    <div class="flow-arrow parallel">
                                        <span><i class="fa-solid fa-arrow-down"></i> 바로</span>
                                        <span class="bg"><i class="fa-solid fa-spinner"></i> 백그라운드</span>
                                    </div>
                                    <div class="flow-step">작업 2 바로 실행</div>
                                </div>
                                <p class="compare-desc">진동벨 받고 자리에서 기다리면 완료 시 알림</p>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">동기 vs 비동기 예시</span>
                        </div>
                        <pre><code><span class="comment">// 동기 코드 - 순서대로 실행</span>
console.log(<span class="string">"1번"</span>);
console.log(<span class="string">"2번"</span>);
console.log(<span class="string">"3번"</span>);
<span class="comment">// 출력: 1번 → 2번 → 3번</span>

<span class="comment">// 비동기 코드 - setTimeout</span>
console.log(<span class="string">"1번"</span>);
setTimeout(() => {
    console.log(<span class="string">"2번 (2초 후)"</span>);
}, <span class="number">2000</span>);
console.log(<span class="string">"3번"</span>);
<span class="comment">// 출력: 1번 → 3번 → 2번 (2초 후)</span></code></pre>
                    </div>

                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>왜 비동기가 필요한가?</h5>
                            <p>JavaScript는 <strong>싱글 스레드</strong> 언어라서 한 번에 하나의 작업만 처리할 수 있다. 서버에서 데이터를 가져오는 동안 화면이 멈추면
                                안 되므로, 시간이 걸리는 작업은 비동기로 처리한다.</p>
                        </div>
                    </div>
                </article>

                <!-- 콜백 함수 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-phone-volume"></i></span>
                        콜백 함수 (Callback)
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-reply"></i> 콜백이란?</h4>
                        <p>다른 함수에 인자로 전달되어, 특정 시점에 <strong>"나중에 불려지는"</strong> 함수. 비동기 작업이 완료되면 콜백 함수가 실행된다.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">콜백 함수 예시</span>
                        </div>
                        <pre><code><span class="comment">// 기본 콜백 패턴</span>
<span class="keyword">function</span> <span class="function">fetchData</span>(callback) {
    setTimeout(() => {
        <span class="keyword">const</span> data = { name: <span class="string">"Kim"</span>, age: <span class="number">25</span> };
        callback(data);  <span class="comment">// 데이터 준비되면 콜백 실행</span>
    }, <span class="number">1000</span>);
}

fetchData(<span class="keyword">function</span>(result) {
    console.log(<span class="string">"받은 데이터:"</span>, result);
});

<span class="comment">// 이벤트 리스너도 콜백 패턴</span>
button.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>() {
    console.log(<span class="string">"클릭됨!"</span>);  <span class="comment">// 클릭 시 콜백 실행</span>
});</code></pre>
                    </div>

                    <div class="highlight-box warning">
                        <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                        <div class="highlight-content">
                            <h5>콜백 지옥 (Callback Hell)</h5>
                            <p>콜백이 중첩되면 코드가 옆으로 계속 들어가서 읽기 어려워진다. 이를 해결하기 위해 <strong>Promise</strong>가 등장했다.</p>
                            <div class="callback-hell-visual">
                                <code>getData(function(a) {</code>
                                <code>    getMore(a, function(b) {</code>
                                <code>        getMore(b, function(c) {</code>
                                <code>            getMore(c, function(d) {</code>
                                <code>                // 콜백 지옥...</code>
                                <code>            });</code>
                                <code>        });</code>
                                <code>    });</code>
                                <code>});</code>
                            </div>
                        </div>
                    </div>
                </article>

                <!-- Promise -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-handshake"></i></span>
                        Promise
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-file-contract"></i> Promise란?</h4>
                        <p>비동기 작업의 <strong>최종 완료 또는 실패</strong>를 나타내는 객체. "약속"처럼 미래에 결과를 알려주겠다는 것.</p>
                    </div>

                    <div class="promise-states">
                        <h4><i class="fa-solid fa-traffic-light"></i> Promise의 3가지 상태</h4>
                        <div class="state-cards">
                            <div class="state-card pending">
                                <div class="state-icon"><i class="fa-solid fa-hourglass"></i></div>
                                <h5>Pending</h5>
                                <p>대기 중 - 아직 결과가 없음</p>
                            </div>
                            <div class="state-card fulfilled">
                                <div class="state-icon"><i class="fa-solid fa-check-circle"></i></div>
                                <h5>Fulfilled</h5>
                                <p>이행됨 - 성공적으로 완료</p>
                            </div>
                            <div class="state-card rejected">
                                <div class="state-icon"><i class="fa-solid fa-times-circle"></i></div>
                                <h5>Rejected</h5>
                                <p>거부됨 - 실패</p>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">Promise 생성과 사용</span>
                        </div>
                        <pre><code><span class="comment">// Promise 생성</span>
<span class="keyword">const</span> myPromise = <span class="keyword">new</span> Promise((resolve, reject) => {
    <span class="keyword">const</span> success = <span class="boolean">true</span>;

    setTimeout(() => {
        <span class="keyword">if</span> (success) {
            resolve(<span class="string">"성공!"</span>);  <span class="comment">// 성공 시</span>
        } <span class="keyword">else</span> {
            reject(<span class="string">"실패..."</span>);  <span class="comment">// 실패 시</span>
        }
    }, <span class="number">1000</span>);
});

<span class="comment">// Promise 사용 (.then, .catch)</span>
myPromise
    .then(result => {
        console.log(result);  <span class="comment">// "성공!"</span>
    })
    .catch(error => {
        console.error(error);  <span class="comment">// 에러 처리</span>
    })
    .finally(() => {
        console.log(<span class="string">"항상 실행"</span>);  <span class="comment">// 성공/실패 상관없이</span>
    });</code></pre>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">Promise 체이닝</span>
                        </div>
                        <pre><code><span class="comment">// 콜백 지옥을 Promise로 해결</span>
fetch(<span class="string">'/api/user'</span>)
    .then(response => response.json())
    .then(user => fetch(<span class="string">`/api/posts/</span><span class="interpolation">${user.id}</span><span class="string">`</span>))
    .then(response => response.json())
    .then(posts => {
        console.log(posts);
    })
    .catch(error => {
        console.error(<span class="string">"에러 발생:"</span>, error);
    });

<span class="comment">// Promise.all - 여러 Promise 동시 실행</span>
Promise.all([
    fetch(<span class="string">'/api/users'</span>),
    fetch(<span class="string">'/api/posts'</span>),
    fetch(<span class="string">'/api/comments'</span>)
]).then(responses => {
    console.log(<span class="string">"모두 완료!"</span>);
});</code></pre>
                    </div>
                </article>

                <!-- async/await -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                        async / await
                    </h3>

                    <div class="content-card highlight">
                        <h4><i class="fa-solid fa-star"></i> async/await란?</h4>
                        <p>Promise를 더 <strong>동기 코드처럼</strong> 읽기 쉽게 작성하는 문법. ES2017(ES8)에서 도입되었으며, <strong>현대
                                JavaScript의 표준</strong>이다.</p>
                    </div>

                    <div class="async-keywords">
                        <div class="keyword-card">
                            <code class="keyword-name">async</code>
                            <p>함수 앞에 붙여서 <strong>"이 함수는 Promise를 반환한다"</strong>고 선언</p>
                        </div>
                        <div class="keyword-card">
                            <code class="keyword-name">await</code>
                            <p>Promise가 처리될 때까지 <strong>기다린 후</strong> 결과값 반환. async 함수 안에서만 사용 가능</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">async/await 기본 사용법</span>
                        </div>
                        <pre><code><span class="comment">// async 함수 선언</span>
<span class="keyword">async function</span> <span class="function">fetchUserData</span>() {
    <span class="comment">// await로 Promise 결과를 기다림</span>
    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/user'</span>);
    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();

    <span class="keyword">return</span> data;
}

<span class="comment">// 화살표 함수로도 가능</span>
<span class="keyword">const</span> getData = <span class="keyword">async</span> () => {
    <span class="keyword">const</span> result = <span class="keyword">await</span> someAsyncTask();
    <span class="keyword">return</span> result;
};

<span class="comment">// 사용</span>
fetchUserData().then(user => console.log(user));</code></pre>
                    </div>

                    <div class="compare-code">
                        <h4><i class="fa-solid fa-code-compare"></i> Promise vs async/await 비교</h4>
                        <div class="compare-panels">
                            <div class="compare-panel">
                                <h5>Promise (.then)</h5>
                                <pre><code>fetch(<span class="string">'/api/user'</span>)
  .then(res => res.json())
  .then(user => {
    <span class="keyword">return</span> fetch(<span class="string">`/api/posts/</span><span class="interpolation">${user.id}</span><span class="string">`</span>);
  })
  .then(res => res.json())
  .then(posts => {
    console.log(posts);
  })
  .catch(err => {
    console.error(err);
  });</code></pre>
                            </div>
                            <div class="compare-panel preferred">
                                <h5>async/await <span class="badge">권장</span></h5>
                                <pre><code><span class="keyword">async function</span> <span class="function">getPosts</span>() {
  <span class="keyword">try</span> {
    <span class="keyword">const</span> res1 = <span class="keyword">await</span> fetch(<span class="string">'/api/user'</span>);
    <span class="keyword">const</span> user = <span class="keyword">await</span> res1.json();

    <span class="keyword">const</span> res2 = <span class="keyword">await</span> fetch(<span class="string">`/api/posts/</span><span class="interpolation">${user.id}</span><span class="string">`</span>);
    <span class="keyword">const</span> posts = <span class="keyword">await</span> res2.json();

    console.log(posts);
  } <span class="keyword">catch</span> (err) {
    console.error(err);
  }
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">에러 처리 (try/catch)</span>
                        </div>
                        <pre><code><span class="keyword">async function</span> <span class="function">fetchWithErrorHandling</span>() {
    <span class="keyword">try</span> {
        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/data'</span>);

        <span class="keyword">if</span> (!response.ok) {
            <span class="keyword">throw new</span> Error(<span class="string">`HTTP error! status: </span><span class="interpolation">${response.status}</span><span class="string">`</span>);
        }

        <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();
        <span class="keyword">return</span> data;

    } <span class="keyword">catch</span> (error) {
        console.error(<span class="string">"데이터 가져오기 실패:"</span>, error);
        <span class="comment">// 사용자에게 에러 메시지 표시</span>
        showErrorMessage(error.message);
    } <span class="keyword">finally</span> {
        <span class="comment">// 로딩 스피너 숨기기 등</span>
        hideLoadingSpinner();
    }
}</code></pre>
                    </div>
                </article>

                <!-- Fetch API -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-cloud-arrow-down"></i></span>
                        Fetch API
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-server"></i> Fetch란?</h4>
                        <p>서버와 HTTP 통신을 위한 <strong>모던 API</strong>. XMLHttpRequest를 대체하며, Promise 기반으로 동작한다.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">Fetch 기본 사용법</span>
                        </div>
                        <pre><code><span class="comment">// GET 요청 (데이터 가져오기)</span>
<span class="keyword">async function</span> <span class="function">getUsers</span>() {
    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'https://api.example.com/users'</span>);
    <span class="keyword">const</span> users = <span class="keyword">await</span> response.json();
    <span class="keyword">return</span> users;
}

<span class="comment">// POST 요청 (데이터 보내기)</span>
<span class="keyword">async function</span> <span class="function">createUser</span>(userData) {
    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'https://api.example.com/users'</span>, {
        method: <span class="string">'POST'</span>,
        headers: {
            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>
        },
        body: JSON.stringify(userData)
    });

    <span class="keyword">const</span> newUser = <span class="keyword">await</span> response.json();
    <span class="keyword">return</span> newUser;
}

<span class="comment">// 사용 예시</span>
createUser({ name: <span class="string">"Kim"</span>, email: <span class="string">"kim@example.com"</span> });</code></pre>
                    </div>

                    <div class="http-methods">
                        <h4><i class="fa-solid fa-list"></i> HTTP 메서드</h4>
                        <div class="method-badges">
                            <div class="http-badge get">
                                <span class="method">GET</span>
                                <span class="desc">데이터 조회</span>
                            </div>
                            <div class="http-badge post">
                                <span class="method">POST</span>
                                <span class="desc">데이터 생성</span>
                            </div>
                            <div class="http-badge put">
                                <span class="method">PUT</span>
                                <span class="desc">데이터 수정 (전체)</span>
                            </div>
                            <div class="http-badge patch">
                                <span class="method">PATCH</span>
                                <span class="desc">데이터 수정 (일부)</span>
                            </div>
                            <div class="http-badge delete">
                                <span class="method">DELETE</span>
                                <span class="desc">데이터 삭제</span>
                            </div>
                        </div>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 11: ES6+ 모던 문법 -->
        <section id="section-es6" class="content-section">
            <div class="section-header">
                <span class="section-number">11</span>
                <h2><i class="fa-solid fa-gem"></i> ES6+ 모던 문법</h2>
            </div>

            <div class="section-body">
                <!-- 스프레드 연산자 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-expand"></i></span>
                        스프레드 연산자 (Spread Operator)
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-ellipsis"></i> ... (점 세 개)</h4>
                        <p>배열이나 객체를 <strong>펼쳐서</strong> 개별 요소로 만든다. 복사, 병합, 함수 인자 전달에 유용하다.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">배열에서 스프레드</span>
                        </div>
                        <pre><code><span class="comment">// 배열 복사</span>
<span class="keyword">const</span> original = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">const</span> copy = [...original];  <span class="comment">// [1, 2, 3] - 독립적인 복사본</span>

<span class="comment">// 배열 합치기</span>
<span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];
<span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];
<span class="keyword">const</span> merged = [...arr1, ...arr2];  <span class="comment">// [1, 2, 3, 4]</span>

<span class="comment">// 배열 중간에 삽입</span>
<span class="keyword">const</span> middle = [<span class="number">2</span>, <span class="number">3</span>];
<span class="keyword">const</span> full = [<span class="number">1</span>, ...middle, <span class="number">4</span>];  <span class="comment">// [1, 2, 3, 4]</span>

<span class="comment">// 함수 인자로 펼치기</span>
<span class="keyword">const</span> numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>];
Math.max(...numbers);  <span class="comment">// 8 (= Math.max(5, 2, 8, 1))</span></code></pre>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">객체에서 스프레드</span>
                        </div>
                        <pre><code><span class="comment">// 객체 복사</span>
<span class="keyword">const</span> user = { name: <span class="string">"Kim"</span>, age: <span class="number">25</span> };
<span class="keyword">const</span> userCopy = { ...user };

<span class="comment">// 객체 합치기 (병합)</span>
<span class="keyword">const</span> defaults = { theme: <span class="string">"light"</span>, lang: <span class="string">"ko"</span> };
<span class="keyword">const</span> userSettings = { theme: <span class="string">"dark"</span> };
<span class="keyword">const</span> settings = { ...defaults, ...userSettings };
<span class="comment">// { theme: "dark", lang: "ko" } - 뒤의 값이 덮어씀</span>

<span class="comment">// 특정 속성만 변경</span>
<span class="keyword">const</span> updated = { ...user, age: <span class="number">26</span> };
<span class="comment">// { name: "Kim", age: 26 }</span></code></pre>
                    </div>
                </article>

                <!-- Rest 파라미터 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-compress"></i></span>
                        Rest 파라미터
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-ellipsis"></i> 나머지 매개변수</h4>
                        <p>스프레드와 모양은 같지만 반대 역할 - 여러 요소를 <strong>하나의 배열로 모은다</strong>.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">Rest 파라미터 사용</span>
                        </div>
                        <pre><code><span class="comment">// 함수에서 나머지 인자 받기</span>
<span class="keyword">function</span> <span class="function">sum</span>(...numbers) {
    <span class="keyword">return</span> numbers.reduce((a, b) => a + b, <span class="number">0</span>);
}
sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 10</span>

<span class="comment">// 첫 번째는 따로, 나머지는 배열로</span>
<span class="keyword">function</span> <span class="function">introduce</span>(first, ...others) {
    console.log(<span class="string">`첫 번째: </span><span class="interpolation">${first}</span><span class="string">`</span>);
    console.log(<span class="string">`나머지: </span><span class="interpolation">${others.join(", ")}</span><span class="string">`</span>);
}
introduce(<span class="string">"Kim"</span>, <span class="string">"Lee"</span>, <span class="string">"Park"</span>);

<span class="comment">// 구조 분해에서 Rest</span>
<span class="keyword">const</span> [first, second, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
console.log(rest);  <span class="comment">// [3, 4, 5]</span>

<span class="keyword">const</span> { name, ...others } = { name: <span class="string">"Kim"</span>, age: <span class="number">25</span>, city: <span class="string">"Seoul"</span> };
console.log(others);  <span class="comment">// { age: 25, city: "Seoul" }</span></code></pre>
                    </div>
                </article>

                <!-- 템플릿 리터럴 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-quote-left"></i></span>
                        템플릿 리터럴 (Template Literal)
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">백틱(`) 활용</span>
                        </div>
                        <pre><code><span class="keyword">const</span> name = <span class="string">"Kim"</span>;
<span class="keyword">const</span> age = <span class="number">25</span>;

<span class="comment">// 기존 방식 (문자열 연결)</span>
<span class="keyword">const</span> old = <span class="string">"이름: "</span> + name + <span class="string">", 나이: "</span> + age;

<span class="comment">// 템플릿 리터럴 (훨씬 깔끔!)</span>
<span class="keyword">const</span> modern = <span class="string">`이름: </span><span class="interpolation">${name}</span><span class="string">, 나이: </span><span class="interpolation">${age}</span><span class="string">`</span>;

<span class="comment">// 표현식 사용 가능</span>
<span class="keyword">const</span> message = <span class="string">`내년 나이: </span><span class="interpolation">${age + 1}</span><span class="string">세`</span>;

<span class="comment">// 여러 줄 문자열 (줄바꿈 그대로 유지)</span>
<span class="keyword">const</span> html = <span class="string">`
  &lt;div class="card"&gt;
    &lt;h2&gt;</span><span class="interpolation">${name}</span><span class="string">&lt;/h2&gt;
    &lt;p&gt;나이: </span><span class="interpolation">${age}</span><span class="string">&lt;/p&gt;
  &lt;/div&gt;
`</span>;

<span class="comment">// 함수 호출도 가능</span>
<span class="keyword">const</span> upper = <span class="string">`대문자: </span><span class="interpolation">${name.toUpperCase()}</span><span class="string">`</span>;</code></pre>
                    </div>
                </article>

                <!-- 옵셔널 체이닝 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-question"></i></span>
                        옵셔널 체이닝 (?.)
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-shield-halved"></i> 안전한 접근</h4>
                        <p>중첩된 객체의 속성에 접근할 때, 중간에 <strong>null이나 undefined</strong>가 있어도 에러 없이 undefined를 반환한다.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">옵셔널 체이닝 사용</span>
                        </div>
                        <pre><code><span class="keyword">const</span> user = {
    name: <span class="string">"Kim"</span>,
    address: {
        city: <span class="string">"Seoul"</span>
    }
};

<span class="comment">// 기존 방식 (장황함)</span>
<span class="keyword">const</span> zipOld = user && user.address && user.address.zip;

<span class="comment">// 옵셔널 체이닝 (간결!)</span>
<span class="keyword">const</span> zip = user?.address?.zip;  <span class="comment">// undefined (에러 없음)</span>
<span class="keyword">const</span> city = user?.address?.city;  <span class="comment">// "Seoul"</span>

<span class="comment">// 메서드 호출에도 사용</span>
user.getProfile?.();  <span class="comment">// 메서드가 있으면 호출, 없으면 undefined</span>

<span class="comment">// 배열 인덱스 접근</span>
<span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
arr?.[<span class="number">10</span>];  <span class="comment">// undefined (에러 없음)</span>

<span class="comment">// nullish 병합과 함께 사용</span>
<span class="keyword">const</span> country = user?.address?.country ?? <span class="string">"한국"</span>;
<span class="comment">// country가 null/undefined면 "한국" 사용</span></code></pre>
                    </div>
                </article>

                <!-- 모듈 시스템 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-puzzle-piece"></i></span>
                        모듈 시스템 (import / export)
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-boxes-stacked"></i> 모듈이란?</h4>
                        <p>코드를 <strong>여러 파일로 분리</strong>하여 관리하는 시스템. 각 파일이 독립적인 스코프를 가지며, 필요한 것만 내보내고 가져온다.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">math.js - 내보내기 (export)</span>
                        </div>
                        <pre><code><span class="comment">// 개별 export (Named Export)</span>
<span class="keyword">export const</span> PI = <span class="number">3.14159</span>;

<span class="keyword">export function</span> <span class="function">add</span>(a, b) {
    <span class="keyword">return</span> a + b;
}

<span class="keyword">export function</span> <span class="function">multiply</span>(a, b) {
    <span class="keyword">return</span> a * b;
}

<span class="comment">// 기본 export (Default Export) - 파일당 1개</span>
<span class="keyword">export default class</span> Calculator {
    <span class="comment">// ...</span>
}</code></pre>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">main.js - 가져오기 (import)</span>
                        </div>
                        <pre><code><span class="comment">// Named Export 가져오기 (중괄호 필요)</span>
<span class="keyword">import</span> { PI, add, multiply } <span class="keyword">from</span> <span class="string">'./math.js'</span>;

console.log(add(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5</span>

<span class="comment">// 이름 바꿔서 가져오기</span>
<span class="keyword">import</span> { add <span class="keyword">as</span> sum } <span class="keyword">from</span> <span class="string">'./math.js'</span>;

<span class="comment">// 전체 가져오기</span>
<span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'./math.js'</span>;
console.log(math.PI);  <span class="comment">// 3.14159</span>

<span class="comment">// Default Export 가져오기 (중괄호 없이)</span>
<span class="keyword">import</span> Calculator <span class="keyword">from</span> <span class="string">'./math.js'</span>;

<span class="comment">// 혼합 사용</span>
<span class="keyword">import</span> Calculator, { PI, add } <span class="keyword">from</span> <span class="string">'./math.js'</span>;</code></pre>
                    </div>

                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>HTML에서 모듈 사용</h5>
                            <p>script 태그에 <code>type="module"</code>을 추가해야 import/export 사용 가능</p>
                            <code>&lt;script type="module" src="main.js"&gt;&lt;/script&gt;</code>
                        </div>
                    </div>
                </article>

                <!-- 단축 속성 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-compress-alt"></i></span>
                        객체 단축 문법
                    </h3>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">단축 속성과 단축 메서드</span>
                        </div>
                        <pre><code><span class="keyword">const</span> name = <span class="string">"Kim"</span>;
<span class="keyword">const</span> age = <span class="number">25</span>;

<span class="comment">// 기존 방식</span>
<span class="keyword">const</span> userOld = {
    name: name,
    age: age,
    greet: <span class="keyword">function</span>() {
        <span class="keyword">return</span> <span class="string">"Hello!"</span>;
    }
};

<span class="comment">// ES6+ 단축 문법</span>
<span class="keyword">const</span> user = {
    name,      <span class="comment">// name: name 과 동일</span>
    age,       <span class="comment">// age: age 와 동일</span>
    greet() {  <span class="comment">// function 키워드 생략</span>
        <span class="keyword">return</span> <span class="string">"Hello!"</span>;
    }
};

<span class="comment">// 계산된 속성명 (Computed Property)</span>
<span class="keyword">const</span> key = <span class="string">"email"</span>;
<span class="keyword">const</span> user2 = {
    [key]: <span class="string">"kim@example.com"</span>,  <span class="comment">// { email: "kim@example.com" }</span>
    [<span class="string">`user_</span><span class="interpolation">${name}</span><span class="string">`</span>]: <span class="boolean">true</span>  <span class="comment">// { user_Kim: true }</span>
};</code></pre>
                    </div>
                </article>
            </div>
        </section>

        <!-- 섹션 12: 이벤트 심화 -->
        <section id="section-events" class="content-section">
            <div class="section-header">
                <span class="section-number">12</span>
                <h2><i class="fa-solid fa-bolt"></i> 이벤트 심화</h2>
            </div>

            <div class="section-body">
                <!-- 섹션 개요 -->
                <div class="section-overview">
                    <div class="overview-intro">
                        <p>이벤트 심화 섹션에서는 JavaScript 이벤트의 고급 개념과 실무 패턴을 다룬다. 기본 이벤트 등록을 넘어서 <strong>전파 제어</strong>, <strong>위임 패턴</strong>, <strong>폼 처리</strong>, <strong>커스텀 이벤트</strong>를 이해하고, 실제 프로젝트에서 바로 사용할 수 있는 인터랙션 코드를 학습한다.</p>
                    </div>
                    <div class="overview-topics">
                        <div class="topic-item">
                            <i class="fa-solid fa-arrow-up-from-bracket"></i>
                            <span>이벤트 전파</span>
                            <small>캡처링, 버블링, stopPropagation</small>
                        </div>
                        <div class="topic-item">
                            <i class="fa-solid fa-sitemap"></i>
                            <span>이벤트 위임</span>
                            <small>성능 최적화, 동적 요소 처리</small>
                        </div>
                        <div class="topic-item">
                            <i class="fa-solid fa-rectangle-list"></i>
                            <span>폼 이벤트</span>
                            <small>input, change, submit 처리</small>
                        </div>
                        <div class="topic-item">
                            <i class="fa-solid fa-wand-sparkles"></i>
                            <span>커스텀 이벤트</span>
                            <small>CustomEvent, dispatchEvent</small>
                        </div>
                        <div class="topic-item">
                            <i class="fa-solid fa-wand-magic-sparkles"></i>
                            <span>실무 인터랙션</span>
                            <small>스크롤, 터치, 애니메이션 패턴</small>
                        </div>
                    </div>
                </div>

                <!-- 이벤트 전파 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-arrow-up-from-bracket"></i></span>
                        이벤트 전파 (Event Propagation)
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-wave-square"></i> 이벤트는 어떻게 전달되나?</h4>
                        <p>DOM 요소에서 이벤트가 발생하면, 해당 요소만이 아니라 <strong>부모 요소들에게도</strong> 이벤트가 전달된다.</p>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-circle-info"></i></div>
                        <div class="highlight-content">
                            <h5>전파를 이해해야 하는 이유</h5>
                            <p>전파를 모르면 “왜 부모가 같이 눌리지?”, “왜 모달 배경 클릭이 같이 먹지?” 같은 현상을 원인 없이 막거나 우연히 해결하게 됩니다. 실제로는 DOM
                                이벤트가 <strong>단일 지점에서만 발생하는 것이 아니라</strong>, 트리 구조를 따라 이동하는 구조이기 때문에 의도적으로 제어해야 합니다.</p>
                            <p>실무에서는 특히 <strong>이벤트 위임</strong>, <strong>모달/드롭다운 닫기</strong>, <strong>중첩 클릭
                                    영역</strong>에서 전파 제어가 핵심입니다.</p>
                        </div>
                    </div>

                    <div class="propagation-visual">
                        <div class="phase-diagram">
                            <div class="phase capturing">
                                <div class="phase-label">1. 캡처링 단계</div>
                                <div class="phase-arrow"><i class="fa-solid fa-arrow-down"></i></div>
                                <p>window → document → ... → 타겟의 부모</p>
                            </div>
                            <div class="phase target">
                                <div class="phase-label">2. 타겟 단계</div>
                                <div class="phase-icon"><i class="fa-solid fa-bullseye"></i></div>
                                <p>실제 클릭된 요소</p>
                            </div>
                            <div class="phase bubbling">
                                <div class="phase-label">3. 버블링 단계</div>
                                <div class="phase-arrow"><i class="fa-solid fa-arrow-up"></i></div>
                                <p>타겟의 부모 → ... → document → window</p>
                            </div>
                        </div>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="content-card">
                        <h4><i class="fa-solid fa-diagram-project"></i> 캡처링 vs 버블링 포인트</h4>
                        <p><strong>버블링</strong>은 대부분의 클릭 처리에서 기본으로 사용되는 전파 방식이다. 그래서 일반적으로는 “자식 → 부모” 순서로 실행되는 것을 기본 전제로
                            둔다.</p>
                        <p><strong>캡처링</strong>은 “부모 → 자식” 순서로 먼저 잡고 싶을 때 사용한다. 예: 특정 영역의 클릭을 최상단에서 먼저 가로채야 하는 보안/차단 로직,
                            전역 로깅, 특정 위젯의 우선 처리 등.</p>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">버블링 예시</span>
                        </div>
                        <pre><code><span class="comment">// HTML: &lt;div id="parent"&gt;&lt;button id="child"&gt;클릭&lt;/button&gt;&lt;/div&gt;</span>

document.getElementById(<span class="string">'parent'</span>).addEventListener(<span class="string">'click'</span>, () => {
    console.log(<span class="string">'부모 클릭!'</span>);
});

document.getElementById(<span class="string">'child'</span>).addEventListener(<span class="string">'click'</span>, () => {
    console.log(<span class="string">'자식 클릭!'</span>);
});

<span class="comment">// 버튼 클릭 시 출력:</span>
<span class="comment">// "자식 클릭!" → "부모 클릭!" (버블링)</span></code></pre>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="highlight-box warning">
                        <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                        <div class="highlight-content">
                            <h5>버그가 자주 나는 패턴</h5>
                            <p>부모와 자식에 클릭이 동시에 걸려있을 때, 의도치 않게 “부모 로직까지 같이 실행”되는 경우가 많습니다.</p>
                            <p>이때 해결은 두 가지 중 하나로 정리됩니다. <strong>(1) 전파 중단</strong>을 명확히 하거나, <strong>(2) 부모에서 target 조건을
                                    걸어</strong> 원하는 클릭만 처리합니다.</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">전파 제어하기</span>
                        </div>
                        <pre><code><span class="comment">// stopPropagation() - 이벤트 전파 중단</span>
child.addEventListener(<span class="string">'click'</span>, (e) => {
    e.stopPropagation();  <span class="comment">// 부모로 전파되지 않음</span>
    console.log(<span class="string">'자식만 실행'</span>);
});

<span class="comment">// preventDefault() - 기본 동작 취소</span>
link.addEventListener(<span class="string">'click'</span>, (e) => {
    e.preventDefault();  <span class="comment">// 링크 이동 취소</span>
    console.log(<span class="string">'페이지 이동 안 함'</span>);
});

<span class="comment">// 캡처링 단계에서 이벤트 잡기</span>
parent.addEventListener(<span class="string">'click'</span>, handler, <span class="boolean">true</span>);  <span class="comment">// 세 번째 인자 true</span>
<span class="comment">// 또는</span>
parent.addEventListener(<span class="string">'click'</span>, handler, { capture: <span class="boolean">true</span> });</code></pre>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="content-card">
                        <h4><i class="fa-solid fa-shield-halved"></i> stopPropagation / preventDefault 정리</h4>
                        <p><strong>stopPropagation()</strong>은 “이벤트가 DOM 트리를 따라 이동하는 것”을 막는다. 즉, 부모로 이벤트가 올라가지 않게 한다.
                        </p>
                        <p><strong>preventDefault()</strong>는 “해당 요소가 원래 하려던 기본 동작”을 막는다. 예: 링크 이동, 폼 제출, 체크박스의 기본 토글 등.
                        </p>
                        <p>둘은 역할이 다르므로, 문제 원인이 “전파”인지 “기본 동작”인지 먼저 분리해야 한다.</p>
                    </div>
                </article>

                <!-- 이벤트 위임 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-sitemap"></i></span>
                        이벤트 위임 (Event Delegation)
                    </h3>

                    <div class="content-card highlight">
                        <h4><i class="fa-solid fa-star"></i> 실무 필수 패턴!</h4>
                        <p>여러 자식 요소에 각각 이벤트를 붙이지 않고, <strong>부모 요소 하나에만</strong> 이벤트를 붙여서 관리하는 패턴. 성능 향상과 동적 요소 처리에
                            필수적이다.</p>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="content-card">
                        <h4><i class="fa-solid fa-bolt"></i> 위임이 성능에 유리한 이유</h4>
                        <p>이벤트 리스너는 “함수 + 연결 정보”를 계속 유지한다. 요소가 많아질수록 리스너 수가 늘고, 메모리/관리 비용이 커진다.</p>
                        <p>위임은 리스너를 <strong>부모 1개</strong>로 고정하고, 실제 클릭된 요소는 <code>e.target</code>으로 판별한다. 따라서 버튼이 100개든
                            1,000개든 리스너는 1개다.</p>
                    </div>

                    <div class="delegation-compare">
                        <div class="delegation-bad">
                            <h4><i class="fa-solid fa-xmark"></i> 비효율적인 방식</h4>
                            <pre><code><span class="comment">// 각 버튼마다 이벤트 등록</span>
<span class="keyword">const</span> buttons = document.querySelectorAll(<span class="string">'.btn'</span>);
buttons.forEach(btn => {
    btn.addEventListener(<span class="string">'click'</span>, handleClick);
});
<span class="comment">// 100개 버튼 = 100개 이벤트 리스너</span>
<span class="comment">// 동적으로 추가된 버튼은 작동 안 함!</span></code></pre>
                        </div>

                        <div class="delegation-good">
                            <h4><i class="fa-solid fa-check"></i> 이벤트 위임 (권장)</h4>
                            <pre><code><span class="comment">// 부모에 한 번만 등록</span>
<span class="keyword">const</span> container = document.getElementById(<span class="string">'container'</span>);
container.addEventListener(<span class="string">'click'</span>, (e) => {
    <span class="keyword">if</span> (e.target.classList.contains(<span class="string">'btn'</span>)) {
        handleClick(e);
    }
});
<span class="comment">// 이벤트 리스너 1개로 모든 버튼 처리!</span>
<span class="comment">// 동적으로 추가된 버튼도 자동 작동!</span></code></pre>
                        </div>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="highlight-box warning">
                        <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                        <div class="highlight-content">
                            <h5>위임에서 가장 흔한 실수</h5>
                            <p>버튼 안에 아이콘(<code>&lt;i&gt;</code>)이나 span이 들어가면, 실제 클릭된 <code>e.target</code>이 버튼이 아니라 내부
                                요소가 될 수 있습니다.</p>
                            <p>이럴 때는 <code>e.target.closest('.btn')</code>로 “의도한 버튼”을 다시 찾아서 처리하는 편이 안전합니다.</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">이벤트 위임 실전 예제</span>
                        </div>
                        <pre><code><span class="comment">// HTML: Todo 리스트</span>
<span class="comment">// &lt;ul id="todoList"&gt;</span>
<span class="comment">//   &lt;li&gt;할 일 1 &lt;button class="delete"&gt;삭제&lt;/button&gt;&lt;/li&gt;</span>
<span class="comment">//   &lt;li&gt;할 일 2 &lt;button class="delete"&gt;삭제&lt;/button&gt;&lt;/li&gt;</span>
<span class="comment">// &lt;/ul&gt;</span>

<span class="keyword">const</span> todoList = document.getElementById(<span class="string">'todoList'</span>);

todoList.addEventListener(<span class="string">'click'</span>, (e) => {
    <span class="comment">// 삭제 버튼 클릭 시</span>
    <span class="keyword">if</span> (e.target.classList.contains(<span class="string">'delete'</span>)) {
        <span class="keyword">const</span> li = e.target.closest(<span class="string">'li'</span>);  <span class="comment">// 가장 가까운 li 찾기</span>
        li.remove();
    }

    <span class="comment">// 완료 체크박스 클릭 시</span>
    <span class="keyword">if</span> (e.target.type === <span class="string">'checkbox'</span>) {
        <span class="keyword">const</span> li = e.target.closest(<span class="string">'li'</span>);
        li.classList.toggle(<span class="string">'completed'</span>);
    }
});

<span class="comment">// 새 항목 추가해도 이벤트 자동 작동!</span>
<span class="keyword">function</span> <span class="function">addTodo</span>(text) {
    <span class="keyword">const</span> li = document.createElement(<span class="string">'li'</span>);
    li.innerHTML = <span class="string">`</span><span class="interpolation">${text}</span><span class="string"> &lt;button class="delete"&gt;삭제&lt;/button&gt;`</span>;
    todoList.appendChild(li);
}</code></pre>
                    </div>

                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>e.target vs e.currentTarget</h5>
                            <ul>
                                <li><strong>e.target</strong> - 실제 이벤트가 발생한 요소 (클릭된 버튼)</li>
                                <li><strong>e.currentTarget</strong> - 이벤트 리스너가 붙은 요소 (부모 컨테이너)</li>
                            </ul>
                        </div>
                    </div>
                </article>

                <!-- 폼 이벤트 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-rectangle-list"></i></span>
                        폼 이벤트
                    </h3>

                    <!-- ✅ 설명 추가 -->
                    <div class="content-card">
                        <h4><i class="fa-solid fa-keyboard"></i> 폼 이벤트가 중요한 지점</h4>
                        <p>폼은 “입력 → 검증 → 제출”이 하나의 흐름으로 묶인 영역입니다. 실무에서는 이벤트 선택을 잘못하면 <strong>검증 타이밍이 어긋나거나</strong>,
                            <strong>불필요한 서버 요청</strong>이 발생합니다.
                        </p>
                        <p><code>input</code>은 즉시 반응이 필요할 때, <code>change/blur</code>는 확정된 시점에만 검사할 때,
                            <code>submit</code>은 최종 게이트로 사용합니다.
                        </p>
                    </div>

                    <div class="event-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>이벤트</th>
                                    <th>발생 시점</th>
                                    <th>주 사용처</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>submit</code></td>
                                    <td>폼 제출 시</td>
                                    <td>폼 유효성 검사, AJAX 제출</td>
                                </tr>
                                <tr>
                                    <td><code>input</code></td>
                                    <td>값이 변경될 때마다 (실시간)</td>
                                    <td>실시간 검색, 글자 수 카운트</td>
                                </tr>
                                <tr>
                                    <td><code>change</code></td>
                                    <td>값 변경 후 포커스 잃을 때</td>
                                    <td>select 변경, 체크박스</td>
                                </tr>
                                <tr>
                                    <td><code>focus</code></td>
                                    <td>요소가 포커스 받을 때</td>
                                    <td>입력 필드 활성화 표시</td>
                                </tr>
                                <tr>
                                    <td><code>blur</code></td>
                                    <td>포커스 잃을 때</td>
                                    <td>입력값 유효성 검사</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="highlight-box warning">
                        <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                        <div class="highlight-content">
                            <h5>submit에서 반드시 하는 것</h5>
                            <p>AJAX 제출이나 SPA 폼 처리에서는 보통 <code>e.preventDefault()</code>로 기본 제출을 막고, 검증 → 전송을 직접 제어합니다.
                            </p>
                            <p>submit 이전에 input/blur로 검증을 해도, submit에서는 “최종 검증”을 한 번 더 하는 편이 안전합니다.</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">폼 유효성 검사 예시</span>
                        </div>
                        <pre><code><span class="keyword">const</span> form = document.getElementById(<span class="string">'signupForm'</span>);
<span class="keyword">const</span> emailInput = document.getElementById(<span class="string">'email'</span>);
<span class="keyword">const</span> passwordInput = document.getElementById(<span class="string">'password'</span>);

<span class="comment">// 실시간 이메일 유효성 검사</span>
emailInput.addEventListener(<span class="string">'input'</span>, (e) => {
    <span class="keyword">const</span> email = e.target.value;
    <span class="keyword">const</span> isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

    e.target.classList.toggle(<span class="string">'invalid'</span>, !isValid);
});

<span class="comment">// 비밀번호 강도 체크 (blur 시)</span>
passwordInput.addEventListener(<span class="string">'blur'</span>, (e) => {
    <span class="keyword">const</span> password = e.target.value;
    <span class="keyword">if</span> (password.length < <span class="number">8</span>) {
        showError(<span class="string">'비밀번호는 8자 이상이어야 합니다.'</span>);
    }
});

<span class="comment">// 폼 제출 처리</span>
form.addEventListener(<span class="string">'submit'</span>, <span class="keyword">async</span> (e) => {
    e.preventDefault();  <span class="comment">// 기본 제출 동작 막기</span>

    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(form);
    <span class="keyword">const</span> data = Object.fromEntries(formData);

    <span class="comment">// 서버로 데이터 전송</span>
    <span class="keyword">try</span> {
        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/signup'</span>, {
            method: <span class="string">'POST'</span>,
            headers: { <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> },
            body: JSON.stringify(data)
        });
        <span class="comment">// 성공 처리</span>
    } <span class="keyword">catch</span> (error) {
        <span class="comment">// 에러 처리</span>
    }
});</code></pre>
                    </div>
                </article>

                <!-- 커스텀 이벤트 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-wand-sparkles"></i></span>
                        커스텀 이벤트
                    </h3>

                    <div class="content-card">
                        <h4><i class="fa-solid fa-plus-circle"></i> 나만의 이벤트 만들기</h4>
                        <p>내장 이벤트 외에 <strong>직접 이벤트를 정의</strong>하여 사용할 수 있다. 컴포넌트 간 통신이나 상태 변화 알림에 유용하다.</p>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="content-card">
                        <h4><i class="fa-solid fa-tower-broadcast"></i> 커스텀 이벤트의 역할</h4>
                        <p>커스텀 이벤트는 “함수 호출로 직접 연결”하지 않고도, 특정 시점에 “무슨 일이 일어났는지”를 방송처럼 알릴 수 있게 합니다.</p>
                        <p>예: 로그인 성공, 장바구니 변경, 모달 열림/닫힘, 데이터 로드 완료 등을 이벤트로 만들어두면 UI 모듈 간 결합도가 낮아집니다.</p>
                    </div>

                    <!-- ✅ 설명 추가 -->
                    <div class="highlight-box info">
                        <div class="highlight-icon"><i class="fa-solid fa-lightbulb"></i></div>
                        <div class="highlight-content">
                            <h5>detail / bubbles 실무 포인트</h5>
                            <p><code>detail</code>은 이벤트에 실어 보내는 데이터다. 상태/메타 정보를 함께 전달할 수 있다.</p>
                            <p><code>bubbles: true</code>를 주면 커스텀 이벤트도 버블링이 가능해져, 위임 패턴과 결합하거나 상위에서 일괄 처리하는 구조로 확장할 수
                                있다.</p>
                        </div>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JavaScript</span>
                            <span class="code-title">커스텀 이벤트 생성 및 발생</span>
                        </div>
                        <pre><code><span class="comment">// 커스텀 이벤트 리스닝</span>
document.addEventListener(<span class="string">'userLoggedIn'</span>, (e) => {
    console.log(<span class="string">'로그인됨:'</span>, e.detail.username);
    updateUI(e.detail);
});

<span class="comment">// 커스텀 이벤트 발생시키기</span>
<span class="keyword">function</span> <span class="function">login</span>(username) {
    <span class="comment">// 로그인 로직...</span>

    <span class="comment">// 커스텀 이벤트 생성</span>
    <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'userLoggedIn'</span>, {
        detail: {
            username: username,
            timestamp: Date.now()
        },
        bubbles: <span class="boolean">true</span>  <span class="comment">// 버블링 허용</span>
    });

    <span class="comment">// 이벤트 발생</span>
    document.dispatchEvent(event);
}</code></pre>
                    </div>
                </article>


                <!-- 실무 인터랙션 예시 -->
                <article class="article-block">
                    <h3 class="article-title">
                        <span class="title-badge"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                        실무 인터랙션 예시
                    </h3>

                    <div class="content-card highlight">
                        <h4><i class="fa-solid fa-fire"></i> 실전에서 바로 쓰는 코드</h4>
                        <p>실무에서 자주 사용하는 인터랙션 패턴들을 모았다. 각 코드는 바로 복사해서 프로젝트에 적용할 수 있으며, 상황에 맞게 수정하여 사용하면 된다. 각 패턴의 동작 원리와
                            활용 방법을 함께 설명한다.</p>
                    </div>

                    <!-- ============================================ -->
                    <!-- 1. 스크롤 이벤트 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-scroll"></i> 스크롤 이벤트</h4>

                        <div class="info-box">
                            <p>스크롤 이벤트는 웹사이트에서 가장 많이 사용되는 인터랙션 중 하나다. 패럴렉스 효과, 요소 애니메이션, 진행률 표시 등 다양한 시각적 효과를 만들 수 있다.
                                성능을 위해 throttle이나 requestAnimationFrame을 함께 사용하는 것이 좋다.</p>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-gauge-high"></i></div>
                            <div class="highlight-content">
                                <h5>스크롤 이벤트의 핵심 문제는 “빈도”</h5>
                                <p>scroll은 사용자가 휠을 굴리는 동안 매우 자주 발생한다. 그래서 무거운 작업(DOM 반복 접근, layout 측정, 큰 루프)을 그대로 넣으면
                                    프레임 드랍이 난다.</p>
                                <p>실무에서는 (1) 계산을 최소화하고 (2) DOM 쓰기(transform/opacity 중심)로 제한하고 (3) 필요하면 rAF/throttle로 호출
                                    빈도를 제어한다.</p>
                            </div>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-layer-group"></i> 스크롤 기반 효과를 분류하면</h4>
                            <p><strong>위치 기반</strong>(패럴렉스/마키/배경 이동), <strong>가시성 기반</strong>(화면에 들어오면 애니메이션),
                                <strong>진행률 기반</strong>(progress bar/헤더 변화), <strong>상태 기반</strong>(방향 감지/섹션 활성화)로 나뉜다.
                            </p>
                            <p>이 분류대로 나누면 “어떤 API가 적합한지”가 바로 결정된다. 위치 기반은 scrollY, 가시성/섹션은 IntersectionObserver, 진행률은 문서
                                높이 계산이 정석이다.</p>
                        </div>

                        <!-- 패럴렉스 기본 -->
                        <h5 class="sub-title">패럴렉스 스크롤 효과</h5>
                        <p class="desc-text">패럴렉스(Parallax)는 배경과 전경이 다른 속도로 움직여 깊이감을 주는 효과다. 스크롤 위치에 따라 요소의 위치를 조절하여
                            구현한다. 히어로 섹션이나 랜딩 페이지에서 자주 사용된다.</p>

                        <!-- 설명 박스 -->
                        <div class="code-explain">
                            <h6><i class="fa-solid fa-lightbulb"></i> 패럴렉스가 "그럴듯하게" 보이는 조건</h6>
                            <ul>
                                <li><strong>상대 속도 차이</strong>로 깊이를 흉내낸다. 속도 값(speed)이 너무 크면 어지럽고, 너무 작으면 효과가 안 보인다.</li>
                                <li><strong>transform 사용</strong>이 핵심이다. top/left를 바꾸면 레이아웃 계산이 발생해 성능이 떨어진다.</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">히어로 섹션</span>
                            <span class="use-case-tag where">랜딩 페이지</span>
                            <span class="use-case-tag when">배경 깊이감 연출할 때</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 패럴렉스 효과</span>
                            </div>
                            <pre><code><span class="comment">// 배경 이미지 패럴렉스 - 가장 기본적인 형태</span>
<span class="comment">// 배경이 스크롤보다 느리게 움직여 깊이감 생성</span>
<span class="keyword">const</span> parallaxBg = document.querySelector(<span class="string">'.parallax-bg'</span>);

window.addEventListener(<span class="string">'scroll'</span>, () => {
    <span class="keyword">const</span> scrollY = window.scrollY;
    <span class="comment">// 0.5 = 스크롤 속도의 50%로 이동 (값이 작을수록 느림)</span>
    parallaxBg.style.transform = <span class="string">`translateY(</span><span class="interpolation">${scrollY * 0.5}</span><span class="string">px)`</span>;
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .parallax-bg {</span>
<span class="comment">//   position: fixed; /* 또는 absolute */</span>
<span class="comment">//   top: 0; left: 0;</span>
<span class="comment">//   width: 100%; height: 100%;</span>
<span class="comment">//   z-index: -1;</span>
<span class="comment">// }</span></code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-screwdriver-wrench"></i> 자주 생기는 이슈</h6>
                            <ul>
                                <li>배경이 fixed일 때 페이지 구조에 따라 끊겨 보이거나 겹칠 수 있다 - z-index뿐 아니라 stacking context도 확인</li>
                                <li>이미지가 크면 성능 저하 - blur/그림자/필터 같은 비싼 효과는 함께 쓰지 않는 것이 안정적</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">포트폴리오</span>
                            <span class="use-case-tag where">게임/앱 소개 페이지</span>
                            <span class="use-case-tag tip">레이어가 3개 이상일 때</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">다중 레이어 패럴렉스</span>
                            </div>
                            <pre><code><span class="comment">// 여러 레이어가 각각 다른 속도로 움직이는 패럴렉스</span>
<span class="comment">// 앞에 있는 요소일수록 빠르게, 뒤에 있을수록 느리게 설정</span>
<span class="keyword">const</span> layers = document.querySelectorAll(<span class="string">'.parallax-layer'</span>);

window.addEventListener(<span class="string">'scroll'</span>, () => {
    layers.forEach((layer, index) => {
        <span class="comment">// data-speed 속성으로 개별 속도 지정 가능</span>
        <span class="keyword">const</span> speed = layer.dataset.speed || (index + <span class="number">1</span>) * <span class="number">0.2</span>;
        <span class="keyword">const</span> yPos = window.scrollY * speed;
        layer.style.transform = <span class="string">`translateY(</span><span class="interpolation">${yPos}</span><span class="string">px)`</span>;
    });
});

<span class="comment">/* HTML 예시 */</span>
<span class="comment">// &lt;div class="parallax-layer" data-speed="0.1"&gt;뒤쪽 산&lt;/div&gt;</span>
<span class="comment">// &lt;div class="parallax-layer" data-speed="0.3"&gt;중간 구름&lt;/div&gt;</span>
<span class="comment">// &lt;div class="parallax-layer" data-speed="0.5"&gt;앞쪽 나무&lt;/div&gt;</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>다중 레이어는 “속도 체계”를 고정해야 안정적</h5>
                                <p>레이어가 많아지면 속도 값이 제멋대로 튀기 쉽다. 실무에서는 data-speed를 “기준 스케일”로 정해두고, 디자인에서 레이어 깊이(전경/중경/후경)와
                                    1:1로 매핑한다.</p>
                                <p>또한 스크롤 이벤트 안에서 매번 dataset을 읽는 대신, 초기 로딩 때 speed를 캐싱해두면 불필요한 비용을 줄일 수 있다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">수평 패럴렉스 효과</span>
                            </div>
                            <pre><code><span class="comment">// 스크롤에 따라 좌우로 움직이는 패럴렉스</span>
<span class="comment">// 텍스트 배너나 장식 요소에 활용</span>
<span class="keyword">const</span> marqueeLeft = document.querySelector(<span class="string">'.marquee-left'</span>);
<span class="keyword">const</span> marqueeRight = document.querySelector(<span class="string">'.marquee-right'</span>);

window.addEventListener(<span class="string">'scroll'</span>, () => {
    <span class="keyword">const</span> scrollY = window.scrollY;
    <span class="comment">// 왼쪽으로 이동</span>
    marqueeLeft.style.transform = <span class="string">`translateX(</span><span class="interpolation">${-scrollY * 0.3}</span><span class="string">px)`</span>;
    <span class="comment">// 오른쪽으로 이동</span>
    marqueeRight.style.transform = <span class="string">`translateX(</span><span class="interpolation">${scrollY * 0.3}</span><span class="string">px)`</span>;
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-arrows-left-right"></i> 수평 패럴렉스는 “클리핑”이 중요</h4>
                            <p>좌우 이동 요소는 뷰포트 밖으로 나가며 잘려야 자연스럽다. 보통 부모 컨테이너에 overflow hidden을 주거나, 텍스트 배너는 반복 구조(마키)로
                                설계한다.</p>
                            <p>움직임이 큰 요소는 사용자의 가독성을 방해할 수 있으니, 배경 장식/보조 타이포에 쓰는 것이 안정적이다.</p>
                        </div>

                        <!-- 스크롤 시 요소 나타나기 -->
                        <h5 class="sub-title">스크롤 시 요소 나타나기 (Reveal Animation)</h5>
                        <p class="desc-text">스크롤하여 특정 요소가 화면에 보일 때 애니메이션을 실행한다. Intersection Observer API를 사용하면 성능 좋게
                            구현할 수 있다. 스크롤 이벤트를 직접 감지하는 것보다 훨씬 효율적이다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-eye"></i> 왜 Intersection Observer를 쓰는가?</h6>
                            <ul>
                                <li>보이는 순간만 알면 되는데 scroll 이벤트로 계속 체크하면 <strong>낭비</strong>다</li>
                                <li>브라우저가 최적화된 방식으로 가시성을 계산해줘서 <strong>성능이 좋다</strong></li>
                                <li>threshold(얼마나 보여야 트리거), rootMargin(감지 영역 조절)으로 타이밍 조절</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">카드/섹션 애니메이션</span>
                            <span class="use-case-tag where">무한 스크롤</span>
                            <span class="use-case-tag when">화면에 보일 때 뭔가 실행할 때</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">Intersection Observer 기본</span>
                            </div>
                            <pre><code><span class="comment">// Intersection Observer - 성능 좋은 스크롤 감지</span>
<span class="comment">// 스크롤 이벤트 직접 사용보다 훨씬 효율적</span>
<span class="keyword">const</span> fadeElements = document.querySelectorAll(<span class="string">'.fade-in'</span>);

<span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver((entries) => {
    entries.forEach(entry => {
        <span class="keyword">if</span> (entry.isIntersecting) {
            entry.target.classList.add(<span class="string">'visible'</span>);
            <span class="comment">// 한 번만 실행하려면 unobserve</span>
            observer.unobserve(entry.target);
        }
    });
}, {
    threshold: <span class="number">0.1</span>,      <span class="comment">// 10% 보이면 실행 (0~1)</span>
    rootMargin: <span class="string">'0px 0px -50px 0px'</span>  <span class="comment">// 하단 50px 여유</span>
});

fadeElements.forEach(el => observer.observe(el));

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .fade-in { opacity: 0; transform: translateY(30px); transition: 0.6s; }</span>
<span class="comment">// .fade-in.visible { opacity: 1; transform: translateY(0); }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-check-double"></i> unobserve를 넣는 이유</h4>
                            <p>애니메이션이 “한 번만” 실행되어야 하면, visible 이후에는 계속 관찰할 이유가 없다. 관찰을 끊으면 이후 스크롤에서도 계산 비용이 줄어든다.</p>
                            <p>반대로, “들어올 때/나갈 때” 모두 반응해야 하는 UI(스티키 상태, 섹션 강조)라면 unobserve를 빼고 상태 토글로 운용한다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">다양한 방향 애니메이션</span>
                            </div>
                            <pre><code><span class="comment">// 방향별 다른 애니메이션 적용</span>
<span class="keyword">const</span> animatedElements = document.querySelectorAll(<span class="string">'[data-animation]'</span>);

<span class="keyword">const</span> animObserver = <span class="keyword">new</span> IntersectionObserver((entries) => {
    entries.forEach(entry => {
        <span class="keyword">if</span> (entry.isIntersecting) {
            <span class="keyword">const</span> animation = entry.target.dataset.animation;
            entry.target.classList.add(animation);  <span class="comment">// 'fade-up', 'fade-left' 등</span>
            animObserver.unobserve(entry.target);
        }
    });
}, { threshold: <span class="number">0.2</span> });

animatedElements.forEach(el => animObserver.observe(el));

<span class="comment">/* HTML 예시 */</span>
<span class="comment">// &lt;div data-animation="fade-up"&gt;위로 나타남&lt;/div&gt;</span>
<span class="comment">// &lt;div data-animation="fade-left"&gt;왼쪽에서 나타남&lt;/div&gt;</span>
<span class="comment">// &lt;div data-animation="scale-up"&gt;확대되며 나타남&lt;/div&gt;</span>

<span class="comment">/* CSS 예시 */</span>
<span class="comment">// .fade-up { animation: fadeUp 0.6s ease forwards; }</span>
<span class="comment">// @keyframes fadeUp { from { opacity: 0; transform: translateY(40px); } }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>클래스 누적 문제</h5>
                                <p>data-animation으로 클래스 추가만 하고 끝내면, 요소에 여러 상태 클래스가 누적될 수 있다. “한 번만 실행”이면 괜찮지만,
                                    재진입형 UI로 바뀌면 상태 정리가 필요하다.</p>
                                <p>실무에서는 애니메이션 클래스와 상태 클래스(visible)를 분리하고, 한쪽만 토글하도록 규칙을 고정하는 편이 유지보수에 유리하다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">순차적 애니메이션 (Stagger)</span>
                            </div>
                            <pre><code><span class="comment">// 여러 요소가 순차적으로 나타나는 효과</span>
<span class="comment">// 카드 리스트, 갤러리 등에 활용</span>
<span class="keyword">const</span> staggerContainer = document.querySelector(<span class="string">'.stagger-container'</span>);
<span class="keyword">const</span> staggerItems = staggerContainer.querySelectorAll(<span class="string">'.stagger-item'</span>);

<span class="keyword">const</span> staggerObserver = <span class="keyword">new</span> IntersectionObserver((entries) => {
    <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting) {
        staggerItems.forEach((item, index) => {
            <span class="comment">// 각 요소마다 100ms 딜레이</span>
            setTimeout(() => {
                item.classList.add(<span class="string">'visible'</span>);
            }, index * <span class="number">100</span>);
        });
        staggerObserver.unobserve(staggerContainer);
    }
}, { threshold: <span class="number">0.1</span> });

staggerObserver.observe(staggerContainer);

<span class="comment">/* CSS 예시 */</span>
<span class="comment">// .stagger-item { opacity: 0; transform: translateY(20px); transition: 0.4s; }</span>
<span class="comment">// .stagger-item.visible { opacity: 1; transform: translateY(0); }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-list-ol"></i> Stagger의 목적은 “시선 유도”</h4>
                            <p>순차 애니메이션은 단순히 예쁜 효과가 아니라, 카드/리스트를 <strong>한 묶음으로 읽게 만드는 리듬</strong>을 만든다.
                                동시에 튀어나오면 시선이 분산되는데, 순차는 자연스럽게 위계가 생긴다.</p>
                            <p>너무 긴 딜레이는 답답함으로 바뀌므로, 실무에서는 60~120ms 범위를 많이 쓴다.</p>
                        </div>

                        <!-- 스크롤 진행률 -->
                        <h5 class="sub-title">스크롤 진행률 및 헤더 효과</h5>
                        <p class="desc-text">페이지 읽기 진행률 표시, 스크롤에 따른 헤더 스타일 변경, 스크롤 방향 감지 등의 기능이다. 블로그, 문서 페이지에서 많이 사용된다.
                        </p>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-book-open"></i></div>
                            <div class="highlight-content">
                                <h5>문서형 UI의 핵심은 “현재 위치를 잃지 않게 하는 것”</h5>
                                <p>진행률 바/섹션 활성화/헤더 변화는 사용자가 “지금 어디를 읽고 있는지”를 계속 확인할 수 있게 한다. 긴 문서일수록 효과가 커진다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">읽기 진행률 바</span>
                            </div>
                            <pre><code><span class="comment">// 페이지 상단에 진행률 바 표시</span>
<span class="comment">// 블로그, 문서 페이지에서 현재 읽은 위치 표시</span>
<span class="keyword">const</span> progressBar = document.querySelector(<span class="string">'.progress-bar'</span>);

window.addEventListener(<span class="string">'scroll'</span>, () => {
    <span class="keyword">const</span> scrollTop = window.scrollY;
    <span class="keyword">const</span> docHeight = document.documentElement.scrollHeight - window.innerHeight;
    <span class="keyword">const</span> progress = (scrollTop / docHeight) * <span class="number">100</span>;
    progressBar.style.width = <span class="string">`</span><span class="interpolation">${progress}</span><span class="string">%`</span>;
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .progress-bar {</span>
<span class="comment">//   position: fixed; top: 0; left: 0;</span>
<span class="comment">//   height: 3px; background: #3498db;</span>
<span class="comment">//   width: 0; z-index: 9999;</span>
<span class="comment">//   transition: width 0.1s;</span>
<span class="comment">// }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-percent"></i> 진행률 계산에서 체크할 것</h4>
                            <p>문서 높이는 <code>scrollHeight - innerHeight</code>로 “실제로 이동 가능한 전체 거리”를 만든 뒤, 현재 scrollTop을
                                나누는 방식이 기본이다.</p>
                            <p>페이지가 짧아서 이동 거리가 거의 없으면 0으로 나눌 수 있는 상황이 생길 수 있으니, 실무에서는 docHeight가 0에 가까울 때 예외 처리도 고려한다.
                            </p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">스크롤 시 헤더 스타일 변경</span>
                            </div>
                            <pre><code><span class="comment">// 스크롤 내리면 헤더에 그림자, 배경색 추가</span>
<span class="keyword">const</span> header = document.querySelector(<span class="string">'.header'</span>);

window.addEventListener(<span class="string">'scroll'</span>, () => {
    <span class="comment">// 100px 이상 스크롤하면 'scrolled' 클래스 추가</span>
    header.classList.toggle(<span class="string">'scrolled'</span>, window.scrollY > <span class="number">100</span>);
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .header { transition: all 0.3s; background: transparent; }</span>
<span class="comment">// .header.scrolled { background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-layer-group"></i></div>
                            <div class="highlight-content">
                                <h5>헤더 효과는 “가독성 보정” 목적이 큼</h5>
                                <p>투명 헤더는 히어로 구간에서는 예쁘지만, 본문 스크롤 구간에서는 텍스트/이미지 위에 겹치며 읽기성을 떨어뜨릴 수 있다.
                                    scrolled 클래스는 “이 구간부터는 읽기 UI”로 전환하는 스위치 역할이다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">스크롤 방향 감지 (헤더 숨기기/보이기)</span>
                            </div>
                            <pre><code><span class="comment">// 아래로 스크롤하면 헤더 숨김, 위로 스크롤하면 보임</span>
<span class="comment">// 모바일에서 화면 공간 확보에 유용</span>
<span class="keyword">const</span> header = document.querySelector(<span class="string">'.header'</span>);
<span class="keyword">let</span> lastScrollY = <span class="number">0</span>;

window.addEventListener(<span class="string">'scroll'</span>, () => {
    <span class="keyword">const</span> currentScrollY = window.scrollY;

    <span class="keyword">if</span> (currentScrollY > lastScrollY && currentScrollY > <span class="number">200</span>) {
        <span class="comment">// 아래로 스크롤 & 200px 이상 내려왔을 때 숨김</span>
        header.classList.add(<span class="string">'hidden'</span>);
    } <span class="keyword">else</span> {
        <span class="comment">// 위로 스크롤하면 보임</span>
        header.classList.remove(<span class="string">'hidden'</span>);
    }
    lastScrollY = currentScrollY;
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .header { position: fixed; transition: transform 0.3s; }</span>
<span class="comment">// .header.hidden { transform: translateY(-100%); }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-mobile-screen"></i> 방향 감지는 “의도치 않은 흔들림”을 막는 게 핵심</h4>
                            <p>스크롤이 아주 조금만 움직여도 방향이 바뀌면서 헤더가 깜빡거릴 수 있다. 그래서 보통은 (1) 특정 임계값 이상일 때만 숨김/노출을 하거나,
                                (2) 방향 변화에 딜레이를 주는 방식으로 안정화한다.</p>
                            <p>지금 코드의 <code>currentScrollY &gt; 200</code> 같은 조건은 “초반 구간에서는 숨기지 않는다”는 안정장치로 의미가 있다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">섹션별 네비게이션 활성화</span>
                            </div>
                            <pre><code><span class="comment">// 현재 보이는 섹션에 해당하는 네비게이션 링크 활성화</span>
<span class="comment">// 원페이지 사이트, 문서 목차에서 사용</span>
<span class="keyword">const</span> sections = document.querySelectorAll(<span class="string">'section[id]'</span>);
<span class="keyword">const</span> navLinks = document.querySelectorAll(<span class="string">'.nav-link'</span>);

<span class="keyword">const</span> sectionObserver = <span class="keyword">new</span> IntersectionObserver((entries) => {
    entries.forEach(entry => {
        <span class="keyword">if</span> (entry.isIntersecting) {
            <span class="keyword">const</span> id = entry.target.id;
            <span class="comment">// 모든 링크 비활성화 후 현재 섹션 링크만 활성화</span>
            navLinks.forEach(link => {
                link.classList.toggle(<span class="string">'active'</span>,
                    link.getAttribute(<span class="string">'href'</span>) === <span class="string">`#</span><span class="interpolation">${id}</span><span class="string">`</span>);
            });
        }
    });
}, {
    threshold: <span class="number">0.3</span>,  <span class="comment">// 30% 보이면 활성화</span>
    rootMargin: <span class="string">'-20% 0px -60% 0px'</span>  <span class="comment">// 화면 중앙 근처에서 감지</span>
});

sections.forEach(section => sectionObserver.observe(section));</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-location-dot"></i></div>
                            <div class="highlight-content">
                                <h5>rootMargin이 사실상 “활성화 기준선”</h5>
                                <p>섹션이 화면 상단에 닿았을 때 활성화하면 너무 늦게 바뀌는 느낌이 날 수 있다. 그래서 보통은 화면 중앙 근처에서 “지금 읽는 섹션”이 바뀌도록 기준선을
                                    당긴다.</p>
                                <p>이 코드의 rootMargin은 상단을 -20%, 하단을 -60%로 잡아서, 대략 화면 중앙 부근에서 섹션이 활성화되도록 만든 설정이다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">스크롤 기반 숫자 카운터</span>
                            </div>
                            <pre><code><span class="comment">// 화면에 보이면 숫자가 0부터 올라가는 효과</span>
<span class="comment">// 통계, 성과 섹션에서 임팩트 있게 표현</span>
<span class="keyword">const</span> counters = document.querySelectorAll(<span class="string">'.counter'</span>);

<span class="keyword">const</span> counterObserver = <span class="keyword">new</span> IntersectionObserver((entries) => {
    entries.forEach(entry => {
        <span class="keyword">if</span> (entry.isIntersecting) {
            <span class="keyword">const</span> counter = entry.target;
            <span class="keyword">const</span> target = parseInt(counter.dataset.target);
            <span class="keyword">const</span> duration = <span class="number">2000</span>;  <span class="comment">// 2초 동안</span>
            <span class="keyword">const</span> increment = target / (duration / <span class="number">16</span>);
            <span class="keyword">let</span> current = <span class="number">0</span>;

            <span class="keyword">const</span> updateCounter = () => {
                current += increment;
                <span class="keyword">if</span> (current < target) {
                    counter.textContent = Math.floor(current).toLocaleString();
                    requestAnimationFrame(updateCounter);
                } <span class="keyword">else</span> {
                    counter.textContent = target.toLocaleString();
                }
            };
            updateCounter();
            counterObserver.unobserve(counter);
        }
    });
}, { threshold: <span class="number">0.5</span> });

counters.forEach(counter => counterObserver.observe(counter));

<span class="comment">/* HTML 예시 */</span>
<span class="comment">// &lt;span class="counter" data-target="1500"&gt;0&lt;/span&gt;+</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>카운터는 “정확도”보다 “체감 리듬”이 중요</h5>
                                <p>duration/16 같은 계산은 대략 60fps 기준의 감각값이다. 실제 프레임은 환경마다 달라질 수 있어 “정확히 2초”를 보장하진 않는다.</p>
                                <p>그래도 UI에서는 “숫자가 자연스럽게 올라가는 느낌”이 핵심이라, 마지막에 target으로 스냅시키는 처리(else)가 실무적으로 필요하다.</p>
                            </div>
                        </div>
                    </div>


                    <!-- ============================================ -->
                    <!-- 2. 클릭 인터랙션 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-hand-pointer"></i> 클릭 인터랙션</h4>

                        <div class="info-box">
                            <p>클릭 이벤트는 사용자와 가장 직접적으로 상호작용하는 방법이다. 메뉴, 모달, 아코디언, 탭 등 대부분의 UI 컴포넌트가 클릭 이벤트를 기반으로 동작한다.
                                접근성을 위해 키보드 이벤트도 함께 처리하는 것이 좋다.</p>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-universal-access"></i></div>
                            <div class="highlight-content">
                                <h5>클릭 인터랙션의 기준은 “상태 전환”과 “접근성”</h5>
                                <p>클릭 기반 UI는 결국 어떤 상태를 바꾸고(열림/닫힘, 선택됨/해제됨) 그 상태가 시각적으로 드러나도록 만드는 구조다. 여기서 실무 품질을 갈라놓는
                                    포인트는 두 가지다.</p>
                                <p>첫째, 닫기/해제 같은 “되돌림”이 항상 존재해야 한다. 둘째, 마우스 클릭만으로 끝내지 않고 키보드(Enter/Space/ESC/Arrow)까지 같은
                                    상태 전환을 보장해야 한다.</p>
                            </div>
                        </div>

                        <!-- 네비게이션 메뉴 -->
                        <h5 class="sub-title">네비게이션 메뉴</h5>
                        <p class="desc-text">모바일 햄버거 메뉴, 드롭다운 메뉴 등 네비게이션 관련 인터랙션이다. 메뉴 열기/닫기, 외부 클릭 감지, 키보드 접근성까지 고려해야
                            한다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-route"></i> 네비게이션 인터랙션에서 반드시 처리해야 하는 것</h4>
                            <p>메뉴는 “열리는 것”보다 “정확히 닫히는 것”이 더 중요하다. 외부 클릭, ESC, 링크 선택 후 닫힘 같은 종료 시나리오가 누락되면 사용자는 UI가 고장났다고
                                느낀다.</p>
                            <p>또한 모바일 오버레이 메뉴는 열리는 순간 배경 스크롤이 같이 움직이면 체감 품질이 급격히 떨어진다. 그래서 스크롤 잠금(no-scroll)이 거의 고정 패턴처럼
                                들어간다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">햄버거 메뉴 (모바일 네비게이션)</span>
                            </div>
                            <pre><code><span class="comment">// 모바일 햄버거 메뉴 토글</span>
<span class="comment">// 열릴 때 배경 스크롤 방지, 외부 클릭/ESC로 닫기</span>
<span class="keyword">const</span> menuBtn = document.querySelector(<span class="string">'.menu-btn'</span>);
<span class="keyword">const</span> nav = document.querySelector(<span class="string">'.nav-menu'</span>);

<span class="comment">// 메뉴 열기/닫기</span>
menuBtn.addEventListener(<span class="string">'click'</span>, () => {
    menuBtn.classList.toggle(<span class="string">'active'</span>);
    nav.classList.toggle(<span class="string">'open'</span>);
    <span class="comment">// 메뉴 열리면 배경 스크롤 방지</span>
    document.body.classList.toggle(<span class="string">'no-scroll'</span>);
});

<span class="comment">// 메뉴 외부 클릭 시 닫기</span>
document.addEventListener(<span class="string">'click'</span>, (e) => {
    <span class="keyword">if</span> (!nav.contains(e.target) && !menuBtn.contains(e.target)) {
        menuBtn.classList.remove(<span class="string">'active'</span>);
        nav.classList.remove(<span class="string">'open'</span>);
        document.body.classList.remove(<span class="string">'no-scroll'</span>);
    }
});

<span class="comment">// ESC 키로 닫기</span>
document.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">if</span> (e.key === <span class="string">'Escape'</span> && nav.classList.contains(<span class="string">'open'</span>)) {
        nav.classList.remove(<span class="string">'open'</span>);
        menuBtn.classList.remove(<span class="string">'active'</span>);
        document.body.classList.remove(<span class="string">'no-scroll'</span>);
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>문서 전체 click 리스너의 비용/충돌</h5>
                                <p>외부 클릭 감지를 위해 document에 click을 달면 편하지만, 페이지가 커질수록 다른 컴포넌트(모달/드롭다운)와 닫힘 로직이 충돌할 수 있다.
                                </p>
                                <p>그래서 실무에서는 “열렸을 때만 document 리스너를 붙였다가 닫힐 때 제거”하거나, 이벤트 위임 구간을 특정 컨테이너로 제한하는 방식으로 관리한다.
                                </p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">드롭다운 메뉴</span>
                            </div>
                            <pre><code><span class="comment">// 클릭으로 열리는 드롭다운 메뉴</span>
<span class="comment">// 다른 드롭다운 열리면 기존 것은 닫힘</span>
<span class="keyword">const</span> dropdowns = document.querySelectorAll(<span class="string">'.dropdown'</span>);

dropdowns.forEach(dropdown => {
    <span class="keyword">const</span> trigger = dropdown.querySelector(<span class="string">'.dropdown-trigger'</span>);
    <span class="keyword">const</span> menu = dropdown.querySelector(<span class="string">'.dropdown-menu'</span>);

    trigger.addEventListener(<span class="string">'click'</span>, (e) => {
        e.stopPropagation();  <span class="comment">// 이벤트 버블링 방지</span>

        <span class="comment">// 다른 드롭다운 닫기</span>
        dropdowns.forEach(d => {
            <span class="keyword">if</span> (d !== dropdown) d.classList.remove(<span class="string">'open'</span>);
        });

        dropdown.classList.toggle(<span class="string">'open'</span>);
    });
});

<span class="comment">// 외부 클릭 시 모든 드롭다운 닫기</span>
document.addEventListener(<span class="string">'click'</span>, () => {
    dropdowns.forEach(d => d.classList.remove(<span class="string">'open'</span>));
});

<span class="comment">/* HTML 구조 */</span>
<span class="comment">// &lt;div class="dropdown"&gt;</span>
<span class="comment">//   &lt;button class="dropdown-trigger"&gt;메뉴&lt;/button&gt;</span>
<span class="comment">//   &lt;ul class="dropdown-menu"&gt;...&lt;/ul&gt;</span>
<span class="comment">// &lt;/div&gt;</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-bullseye"></i> 드롭다운에서 stopPropagation을 쓰는 이유</h4>
                            <p>외부 클릭으로 닫기 로직을 document에 달아두면, 트리거를 클릭하는 순간에도 document click이 같이 실행되어 “열자마자 닫히는” 현상이 발생할
                                수 있다.</p>
                            <p>그래서 트리거 클릭 이벤트는 버블링을 막아 “내부 클릭”과 “외부 클릭”을 분리한다. 이 패턴이 안정적으로 동작하려면 내부 영역(nav/menu)의 클릭 경계가
                                명확해야 한다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">호버/클릭 둘 다 지원하는 드롭다운</span>
                            </div>
                            <pre><code><span class="comment">// PC에서는 호버, 모바일에서는 클릭으로 동작</span>
<span class="keyword">const</span> dropdown = document.querySelector(<span class="string">'.dropdown'</span>);
<span class="keyword">const</span> isMobile = () => window.innerWidth < <span class="number">768</span>;

<span class="comment">// 모바일: 클릭 이벤트</span>
dropdown.addEventListener(<span class="string">'click'</span>, (e) => {
    <span class="keyword">if</span> (isMobile()) {
        e.preventDefault();
        dropdown.classList.toggle(<span class="string">'open'</span>);
    }
});

<span class="comment">// PC: 마우스 오버/아웃 이벤트</span>
dropdown.addEventListener(<span class="string">'mouseenter'</span>, () => {
    <span class="keyword">if</span> (!isMobile()) dropdown.classList.add(<span class="string">'open'</span>);
});
dropdown.addEventListener(<span class="string">'mouseleave'</span>, () => {
    <span class="keyword">if</span> (!isMobile()) dropdown.classList.remove(<span class="string">'open'</span>);
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-mobile-screen-button"></i></div>
                            <div class="highlight-content">
                                <h5>반응형 분기(isMobile)의 현실적인 한계</h5>
                                <p>innerWidth 기준 분기는 “터치 디바이스인데 화면이 큰 경우(태블릿)” 같은 예외가 생긴다. 엄밀하게 하려면 pointer/hover 미디어쿼리,
                                    matchMedia 등을 같이 본다.</p>
                                <p>다만 교육/샘플에서는 innerWidth로 원리를 보여주는 것이 명확하다. 실무로 가져갈 때만 “입력 장치 기반 분기”로 바꾸면 된다.</p>
                            </div>
                        </div>

                        <!-- 아코디언 -->
                        <h5 class="sub-title">아코디언 (접기/펼치기)</h5>
                        <p class="desc-text">FAQ, 상세 정보 표시 등에 사용되는 아코디언이다. 하나만 열리게 할 수도 있고, 여러 개가 동시에 열리게 할 수도 있다.
                            maxHeight를 사용해 부드러운 애니메이션을 구현한다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-bars-staggered"></i> 아코디언의 핵심은 “상태 단일화”</h4>
                            <p>아코디언은 active 상태가 어디에 저장되는지가 핵심이다. item에 active를 주면 스타일과 로직이 단순해지고, 열림/닫힘을 명확히 통제할 수 있다.
                            </p>
                            <p>또한 이벤트 위임을 쓰면 항목이 추가/삭제되어도 리스너를 다시 달 필요가 없다. FAQ 같이 항목이 많은 UI일수록 이 방식이 유리하다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">아코디언 (하나만 열리는 방식)</span>
                            </div>
                            <pre><code><span class="comment">// FAQ 아코디언 - 하나를 열면 다른 것은 자동으로 닫힘</span>
<span class="comment">// 이벤트 위임으로 효율적으로 처리</span>
<span class="keyword">const</span> accordion = document.querySelector(<span class="string">'.accordion'</span>);

accordion.addEventListener(<span class="string">'click'</span>, (e) => {
    <span class="keyword">const</span> header = e.target.closest(<span class="string">'.accordion-header'</span>);
    <span class="keyword">if</span> (!header) <span class="keyword">return</span>;

    <span class="keyword">const</span> item = header.parentElement;
    <span class="keyword">const</span> content = item.querySelector(<span class="string">'.accordion-content'</span>);
    <span class="keyword">const</span> isOpen = item.classList.contains(<span class="string">'active'</span>);

    <span class="comment">// 모든 항목 닫기</span>
    accordion.querySelectorAll(<span class="string">'.accordion-item'</span>).forEach(i => {
        i.classList.remove(<span class="string">'active'</span>);
        i.querySelector(<span class="string">'.accordion-content'</span>).style.maxHeight = <span class="keyword">null</span>;
    });

    <span class="comment">// 클릭한 항목 열기 (이미 열려있었으면 닫힘)</span>
    <span class="keyword">if</span> (!isOpen) {
        item.classList.add(<span class="string">'active'</span>);
        content.style.maxHeight = content.scrollHeight + <span class="string">'px'</span>;
    }
});

<span class="comment">/* HTML 구조 */</span>
<span class="comment">// &lt;div class="accordion"&gt;</span>
<span class="comment">//   &lt;div class="accordion-item"&gt;</span>
<span class="comment">//     &lt;div class="accordion-header"&gt;질문&lt;/div&gt;</span>
<span class="comment">//     &lt;div class="accordion-content"&gt;답변&lt;/div&gt;</span>
<span class="comment">//   &lt;/div&gt;</span>
<span class="comment">// &lt;/div&gt;</span>

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.3s; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>maxHeight 애니메이션의 구조적 한계</h5>
                                <p>max-height는 “자동 높이(auto)”로는 트랜지션이 안 되기 때문에 scrollHeight 값을 직접 넣는 우회가 필요하다.</p>
                                <p>그리고 내부 컨텐츠가 동적으로 변하면(이미지 로딩, 폰트 로딩) scrollHeight가 바뀌어 애니메이션이 어긋날 수 있다. 실무에서는
                                    ResizeObserver로 보정하거나, 애초에 height 기반 대신 transform 기반 연출로 바꾸기도 한다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">아코디언 (여러 개 동시에 열리는 방식)</span>
                            </div>
                            <pre><code><span class="comment">// 여러 항목을 동시에 열 수 있는 아코디언</span>
<span class="keyword">const</span> accordionMulti = document.querySelector(<span class="string">'.accordion-multi'</span>);

accordionMulti.addEventListener(<span class="string">'click'</span>, (e) => {
    <span class="keyword">const</span> header = e.target.closest(<span class="string">'.accordion-header'</span>);
    <span class="keyword">if</span> (!header) <span class="keyword">return</span>;

    <span class="keyword">const</span> item = header.parentElement;
    <span class="keyword">const</span> content = item.querySelector(<span class="string">'.accordion-content'</span>);

    item.classList.toggle(<span class="string">'active'</span>);

    <span class="keyword">if</span> (item.classList.contains(<span class="string">'active'</span>)) {
        content.style.maxHeight = content.scrollHeight + <span class="string">'px'</span>;
    } <span class="keyword">else</span> {
        content.style.maxHeight = <span class="keyword">null</span>;
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-object-group"></i> 단일 오픈 vs 멀티 오픈의 선택 기준</h4>
                            <p>단일 오픈은 사용자의 주의를 한 곳에 고정시키고, 멀티 오픈은 비교/참조를 허용한다. FAQ는 보통 단일 오픈이 깔끔하고, 상세 옵션/설정 화면은 멀티 오픈이
                                더 자연스럽다.</p>
                        </div>

                        <!-- 탭 메뉴 -->
                        <h5 class="sub-title">탭 메뉴</h5>
                        <p class="desc-text">컨텐츠를 분류해서 보여줄 때 사용하는 탭 UI다. data 속성을 활용해 간결하게 구현할 수 있다. 접근성을 위해 aria 속성과
                            키보드 네비게이션도 추가하면 좋다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-diagram-project"></i></div>
                            <div class="highlight-content">
                                <h5>탭은 “선택 상태” UI</h5>
                                <p>탭은 열린/닫힘보다 “현재 선택된 분류가 무엇인지”가 본질이다. 그래서 active는 버튼과 컨텐츠에 동시에 존재해야 일관성이 생긴다.</p>
                                <p>또한 data-tab → id 연결은 유지보수에 유리하다. 순서(index)에 의존하면 DOM 구조가 바뀔 때 깨지기 쉽다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 탭 메뉴</span>
                            </div>
                            <pre><code><span class="comment">// 기본 탭 - data-tab 속성으로 연결</span>
<span class="keyword">const</span> tabBtns = document.querySelectorAll(<span class="string">'.tab-btn'</span>);
<span class="keyword">const</span> tabContents = document.querySelectorAll(<span class="string">'.tab-content'</span>);

tabBtns.forEach(btn => {
    btn.addEventListener(<span class="string">'click'</span>, () => {
        <span class="keyword">const</span> target = btn.dataset.tab;  <span class="comment">// data-tab="tab1"</span>

        <span class="comment">// 모든 버튼, 컨텐츠 비활성화</span>
        tabBtns.forEach(b => b.classList.remove(<span class="string">'active'</span>));
        tabContents.forEach(c => c.classList.remove(<span class="string">'active'</span>));

        <span class="comment">// 선택된 것만 활성화</span>
        btn.classList.add(<span class="string">'active'</span>);
        document.getElementById(target).classList.add(<span class="string">'active'</span>);
    });
});

<span class="comment">/* HTML 구조 */</span>
<span class="comment">// &lt;div class="tab-buttons"&gt;</span>
<span class="comment">//   &lt;button class="tab-btn active" data-tab="tab1"&gt;탭1&lt;/button&gt;</span>
<span class="comment">//   &lt;button class="tab-btn" data-tab="tab2"&gt;탭2&lt;/button&gt;</span>
<span class="comment">// &lt;/div&gt;</span>
<span class="comment">// &lt;div class="tab-content active" id="tab1"&gt;내용1&lt;/div&gt;</span>
<span class="comment">// &lt;div class="tab-content" id="tab2"&gt;내용2&lt;/div&gt;</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-code-branch"></i> 탭 구현에서 자주 놓치는 것</h4>
                            <p>탭은 “컨텐츠만 바뀌고 버튼 시각 상태가 안 바뀌는” 버그가 가장 흔하다. 그래서 버튼/컨텐츠를 같이 초기화하고 같이 활성화하는 형태가 안전하다.</p>
                            <p>또한 컨텐츠가 많아지면, 클릭 때마다 전부 remove하는 방식은 단순하지만 비용이 늘어난다. 실무에서는 “현재 active만 기억하고 이전 것만 끄는
                                방식”으로 최적화하기도 한다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">슬라이딩 인디케이터가 있는 탭</span>
                            </div>
                            <pre><code><span class="comment">// 활성 탭 아래에 인디케이터가 슬라이드되는 효과</span>
<span class="keyword">const</span> tabContainer = document.querySelector(<span class="string">'.tabs'</span>);
<span class="keyword">const</span> tabBtns = tabContainer.querySelectorAll(<span class="string">'.tab-btn'</span>);
<span class="keyword">const</span> indicator = tabContainer.querySelector(<span class="string">'.tab-indicator'</span>);

<span class="keyword">function</span> <span class="function">moveIndicator</span>(btn) {
    indicator.style.width = btn.offsetWidth + <span class="string">'px'</span>;
    indicator.style.left = btn.offsetLeft + <span class="string">'px'</span>;
}

<span class="comment">// 초기 위치 설정</span>
<span class="keyword">const</span> activeBtn = tabContainer.querySelector(<span class="string">'.tab-btn.active'</span>);
<span class="keyword">if</span> (activeBtn) moveIndicator(activeBtn);

tabBtns.forEach(btn => {
    btn.addEventListener(<span class="string">'click'</span>, () => {
        tabBtns.forEach(b => b.classList.remove(<span class="string">'active'</span>));
        btn.classList.add(<span class="string">'active'</span>);
        moveIndicator(btn);
    });
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .tab-indicator {</span>
<span class="comment">//   position: absolute; bottom: 0;</span>
<span class="comment">//   height: 3px; background: #3498db;</span>
<span class="comment">//   transition: all 0.3s ease;</span>
<span class="comment">// }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-ruler-combined"></i></div>
                            <div class="highlight-content">
                                <h5>인디케이터는 레이아웃 측정 비용이 있다</h5>
                                <p>offsetWidth/offsetLeft는 레이아웃 값을 읽는 작업이라, 호출 빈도가 높아지면 비용이 생길 수 있다. 클릭 정도면 문제 없지만,
                                    리사이즈/스크롤 연동까지 붙이면 rAF로 묶어주는 편이 안전하다.</p>
                                <p>또한 웹폰트 로딩 후 버튼 폭이 달라질 수 있으니, 폰트 로딩 완료나 window load 시점에 한 번 더 보정하는 경우도 있다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">키보드 네비게이션 지원 탭</span>
                            </div>
                            <pre><code><span class="comment">// 화살표 키로 탭 이동 가능한 접근성 탭</span>
<span class="keyword">const</span> tabList = document.querySelector(<span class="string">'[role="tablist"]'</span>);
<span class="keyword">const</span> tabs = tabList.querySelectorAll(<span class="string">'[role="tab"]'</span>);

tabList.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">const</span> currentIndex = [...tabs].indexOf(document.activeElement);
    <span class="keyword">let</span> newIndex;

    <span class="keyword">switch</span> (e.key) {
        <span class="keyword">case</span> <span class="string">'ArrowRight'</span>:
            newIndex = (currentIndex + <span class="number">1</span>) % tabs.length;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'ArrowLeft'</span>:
            newIndex = (currentIndex - <span class="number">1</span> + tabs.length) % tabs.length;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'Home'</span>:
            newIndex = <span class="number">0</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'End'</span>:
            newIndex = tabs.length - <span class="number">1</span>;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="keyword">return</span>;
    }

    e.preventDefault();
    tabs[newIndex].focus();
    tabs[newIndex].click();
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-keyboard"></i> 접근성 탭의 최소 조건</h4>
                            <p>role/tablist/tab이 들어가면 “스크린리더가 탭 UI로 인식하는 구조”가 된다. 여기에 키보드 이동(좌/우, Home/End)을 붙이면 탭의 기본
                                규약을 충족한다.</p>
                            <p>추가로 엄밀하게 하려면 aria-selected, tabindex(로빙 tabindex), aria-controls/aria-labelledby까지 세팅하면
                                완성도가 올라간다.</p>
                        </div>

                        <!-- 모달 -->
                        <h5 class="sub-title">모달 팝업</h5>
                        <p class="desc-text">중요한 정보 표시, 확인 대화상자, 이미지 라이트박스 등에 사용되는 모달이다. 열릴 때 배경 스크롤 방지, 닫기 버튼, 오버레이 클릭,
                            ESC 키 등 여러 닫기 방법을 제공해야 한다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-door-open"></i> 모달의 핵심 = 포커스 제어</h6>
                            <ul>
                                <li>열릴 때 모달 내부로 포커스 이동</li>
                                <li>닫힐 때 원래 트리거 버튼으로 포커스 복귀</li>
                                <li>실무에서는 "포커스 트랩(모달 밖으로 탭 이동 방지)"까지 넣어야 완성형</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">확인 다이얼로그</span>
                            <span class="use-case-tag where">로그인 폼</span>
                            <span class="use-case-tag where">상세 정보</span>
                            <span class="use-case-tag tip">접근성 필수</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 모달</span>
                            </div>
                            <pre><code><span class="comment">// 기본 모달 - 열기/닫기 + 접근성</span>
<span class="keyword">const</span> modal = document.querySelector(<span class="string">'.modal'</span>);
<span class="keyword">const</span> openBtn = document.querySelector(<span class="string">'.open-modal'</span>);
<span class="keyword">const</span> closeBtn = document.querySelector(<span class="string">'.close-modal'</span>);
<span class="keyword">const</span> overlay = document.querySelector(<span class="string">'.modal-overlay'</span>);

<span class="comment">// 열기</span>
openBtn.addEventListener(<span class="string">'click'</span>, () => {
    modal.classList.add(<span class="string">'active'</span>);
    document.body.style.overflow = <span class="string">'hidden'</span>;  <span class="comment">// 배경 스크롤 방지</span>
    closeBtn.focus();  <span class="comment">// 닫기 버튼에 포커스</span>
});

<span class="comment">// 닫기 함수</span>
<span class="keyword">function</span> <span class="function">closeModal</span>() {
    modal.classList.remove(<span class="string">'active'</span>);
    document.body.style.overflow = <span class="string">''</span>;
    openBtn.focus();  <span class="comment">// 원래 버튼으로 포커스 복귀</span>
}

<span class="comment">// 다양한 닫기 방법</span>
closeBtn.addEventListener(<span class="string">'click'</span>, closeModal);
overlay.addEventListener(<span class="string">'click'</span>, closeModal);
document.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">if</span> (e.key === <span class="string">'Escape'</span> && modal.classList.contains(<span class="string">'active'</span>)) {
        closeModal();
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>모달이 여러 개일 때의 이벤트 충돌</h5>
                                <p>document keydown(ESC) 같은 전역 리스너는 모달이 많아지면 충돌한다. 열린 모달만 닫히게 하려면 “현재 열린 모달 참조”를 유지하거나,
                                    열릴 때 리스너를 등록하고 닫힐 때 제거하는 방식이 관리하기 쉽다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">이미지 라이트박스</span>
                            </div>
                            <pre><code><span class="comment">// 이미지 클릭 시 전체화면으로 보기</span>
<span class="comment">// 갤러리, 포트폴리오에서 사용</span>
<span class="keyword">const</span> lightbox = document.querySelector(<span class="string">'.lightbox'</span>);
<span class="keyword">const</span> lightboxImg = lightbox.querySelector(<span class="string">'img'</span>);
<span class="keyword">const</span> galleryImages = document.querySelectorAll(<span class="string">'.gallery-img'</span>);

galleryImages.forEach(img => {
    img.addEventListener(<span class="string">'click'</span>, () => {
        lightboxImg.src = img.dataset.fullsize || img.src;
        lightbox.classList.add(<span class="string">'active'</span>);
        document.body.style.overflow = <span class="string">'hidden'</span>;
    });
});

<span class="comment">// 클릭하면 닫기</span>
lightbox.addEventListener(<span class="string">'click'</span>, () => {
    lightbox.classList.remove(<span class="string">'active'</span>);
    document.body.style.overflow = <span class="string">''</span>;
});

<span class="comment">/* HTML 구조 */</span>
<span class="comment">// &lt;img class="gallery-img" src="thumb.jpg" data-fullsize="full.jpg"&gt;</span>
<span class="comment">// &lt;div class="lightbox"&gt;&lt;img&gt;&lt;/div&gt;</span>

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .lightbox { position: fixed; inset: 0; display: none; background: rgba(0,0,0,0.9); }</span>
<span class="comment">// .lightbox.active { display: flex; justify-content: center; align-items: center; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-image"></i> 라이트박스에서 자주 추가되는 실무 요소</h4>
                            <p>단순히 켜고 끄는 것만으로 끝내면 기능이 약하다. 실무에서는 다음이 자주 붙는다: (1) ESC로 닫기, (2) 좌/우 키로 이미지 넘기기,
                                (3) 이미지 로딩 전 스피너, (4) 원본 비율 유지와 최대 폭/높이 제한.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">확인 모달 (Confirm Dialog)</span>
                            </div>
                            <pre><code><span class="comment">// Promise 기반 확인 모달 - await로 사용 가능</span>
<span class="keyword">function</span> <span class="function">showConfirm</span>(message) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise((resolve) => {
        <span class="keyword">const</span> modal = document.createElement(<span class="string">'div'</span>);
        modal.className = <span class="string">'confirm-modal'</span>;
        modal.innerHTML = <span class="string">`
            &lt;div class="confirm-overlay"&gt;&lt;/div&gt;
            &lt;div class="confirm-box"&gt;
                &lt;p&gt;</span><span class="interpolation">${message}</span><span class="string">&lt;/p&gt;
                &lt;div class="confirm-buttons"&gt;
                    &lt;button class="btn-cancel"&gt;취소&lt;/button&gt;
                    &lt;button class="btn-confirm"&gt;확인&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        `</span>;

        document.body.appendChild(modal);

        <span class="keyword">const</span> cleanup = (result) => {
            modal.remove();
            resolve(result);
        };

        modal.querySelector(<span class="string">'.btn-confirm'</span>).onclick = () => cleanup(<span class="boolean">true</span>);
        modal.querySelector(<span class="string">'.btn-cancel'</span>).onclick = () => cleanup(<span class="boolean">false</span>);
        modal.querySelector(<span class="string">'.confirm-overlay'</span>).onclick = () => cleanup(<span class="boolean">false</span>);
    });
}

<span class="comment">// 사용 예시</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">deleteItem</span>() {
    <span class="keyword">const</span> confirmed = <span class="keyword">await</span> showConfirm(<span class="string">'정말 삭제하시겠습니까?'</span>);
    <span class="keyword">if</span> (confirmed) {
        <span class="comment">// 삭제 처리</span>
        console.log(<span class="string">'삭제됨'</span>);
    }
}</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-code"></i></div>
                            <div class="highlight-content">
                                <h5>Promise 기반 Confirm의 장점</h5>
                                <p>UI는 이벤트 기반이지만, 비즈니스 로직은 “확인되면 진행” 같은 순서 구조가 많다. Promise로 감싸면 <code>await</code>로 흐름을
                                    직선화할 수 있어 코드가 읽기 쉬워진다.</p>
                                <p>다만 남발하면 DOM을 계속 만들고 제거하므로, 재사용 가능한 confirm 컴포넌트(싱글턴)로 정리하는 경우가 많다.</p>
                            </div>
                        </div>

                        <!-- 토글/스위치 -->
                        <h5 class="sub-title">토글 및 기타 클릭 효과</h5>
                        <p class="desc-text">좋아요 버튼, 테마 토글, 더보기/접기 버튼 등 간단한 상태 전환 인터랙션이다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-toggle-on"></i> 토글 패턴의 핵심</h4>
                            <p>토글 UI는 단순하지만 “상태의 단일 소스”를 유지해야 한다. DOM 클래스(active/liked)와 JS 변수(isLiked)가 서로 불일치하면 버그가
                                생긴다.</p>
                            <p>그래서 가능하면 하나를 기준으로 삼는다. 예를 들어 상태는 클래스에서 읽고, 카운트만 계산하거나, 상태는 변수로 두고 렌더링을 한 번에 갱신하는 식이다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">좋아요 버튼</span>
                            </div>
                            <pre><code><span class="comment">// 좋아요 토글 + 카운트 업데이트</span>
<span class="keyword">const</span> likeBtn = document.querySelector(<span class="string">'.like-btn'</span>);
<span class="keyword">const</span> likeCount = document.querySelector(<span class="string">'.like-count'</span>);
<span class="keyword">let</span> count = parseInt(likeCount.textContent);
<span class="keyword">let</span> isLiked = <span class="boolean">false</span>;

likeBtn.addEventListener(<span class="string">'click'</span>, () => {
    isLiked = !isLiked;
    likeBtn.classList.toggle(<span class="string">'liked'</span>);
    count += isLiked ? <span class="number">1</span> : -<span class="number">1</span>;
    likeCount.textContent = count;

    <span class="comment">// 버튼 애니메이션</span>
    likeBtn.classList.add(<span class="string">'animate'</span>);
    setTimeout(() => likeBtn.classList.remove(<span class="string">'animate'</span>), <span class="number">300</span>);
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .like-btn.liked { color: red; }</span>
<span class="comment">// .like-btn.animate { animation: pop 0.3s; }</span>
<span class="comment">// @keyframes pop { 50% { transform: scale(1.3); } }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>좋아요 카운트의 실무 현실</h5>
                                <p>로컬에서 count를 올리는 방식은 “즉시 반응”은 좋지만, 서버와 동기화가 깨질 수 있다. 실무에서는 낙관적 업데이트(optimistic update)
                                    후 실패 시 롤백 전략이 필요하다.</p>
                                <p>또한 초기 isLiked는 서버 데이터/DOM 데이터 속성에서 읽어오는 방식으로 시작해야 일관성이 생긴다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">다크 모드 토글</span>
                            </div>
                            <pre><code><span class="comment">// 다크 모드 전환 + 로컬 스토리지 저장</span>
<span class="keyword">const</span> themeToggle = document.querySelector(<span class="string">'.theme-toggle'</span>);

<span class="comment">// 저장된 테마 불러오기</span>
<span class="keyword">const</span> savedTheme = localStorage.getItem(<span class="string">'theme'</span>);
<span class="keyword">if</span> (savedTheme === <span class="string">'dark'</span>) {
    document.body.classList.add(<span class="string">'dark-mode'</span>);
}

themeToggle.addEventListener(<span class="string">'click'</span>, () => {
    document.body.classList.toggle(<span class="string">'dark-mode'</span>);

    <span class="comment">// 로컬 스토리지에 저장</span>
    <span class="keyword">const</span> isDark = document.body.classList.contains(<span class="string">'dark-mode'</span>);
    localStorage.setItem(<span class="string">'theme'</span>, isDark ? <span class="string">'dark'</span> : <span class="string">'light'</span>);
});

<span class="comment">/* CSS 변수 활용 */</span>
<span class="comment">// :root { --bg: white; --text: black; }</span>
<span class="comment">// .dark-mode { --bg: #1a1a1a; --text: white; }</span>
<span class="comment">// body { background: var(--bg); color: var(--text); }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-palette"></i> 테마 토글의 기준점</h4>
                            <p>클래스를 바꾸는 방식은 단순하고 강력하다. 특히 CSS 변수를 테마 스위치로 쓰면, 컴포넌트별 스타일을 다시 쓰지 않고도 전체 색상 체계를 전환할 수 있다.
                            </p>
                            <p>추가로 OS 설정을 존중하려면 prefers-color-scheme을 기준으로 초기 테마를 잡고, 사용자가 토글하면 그 설정을 우선하는 방식이 흔하다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">더보기/접기 버튼</span>
                            </div>
                            <pre><code><span class="comment">// 긴 텍스트 더보기/접기</span>
<span class="keyword">const</span> textContainer = document.querySelector(<span class="string">'.text-container'</span>);
<span class="keyword">const</span> toggleBtn = document.querySelector(<span class="string">'.toggle-text'</span>);

toggleBtn.addEventListener(<span class="string">'click'</span>, () => {
    <span class="keyword">const</span> isExpanded = textContainer.classList.toggle(<span class="string">'expanded'</span>);
    toggleBtn.textContent = isExpanded ? <span class="string">'접기'</span> : <span class="string">'더보기'</span>;
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .text-container {</span>
<span class="comment">//   max-height: 100px; overflow: hidden;</span>
<span class="comment">//   transition: max-height 0.3s;</span>
<span class="comment">// }</span>
<span class="comment">// .text-container.expanded { max-height: 1000px; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-align-left"></i></div>
                            <div class="highlight-content">
                                <h5>더보기 UI의 실무 포인트</h5>
                                <p>접기/펼치기는 “버튼 라벨”과 “상태”가 맞아야 한다. 그래서 지금처럼 토글 결과(isExpanded)로 라벨을 결정하는 방식이 안전하다.</p>
                                <p>또한 펼쳤을 때 레이아웃이 크게 밀리면 사용자가 읽던 위치를 잃을 수 있다. 필요하면 펼친 뒤 스크롤 보정(열린 위치로 스크롤 이동)까지 고려한다.
                                </p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">클립보드 복사</span>
                            </div>
                            <pre><code><span class="comment">// 텍스트 클립보드에 복사</span>
<span class="comment">// 코드 블록, 공유 링크 등에서 사용</span>
<span class="keyword">const</span> copyBtns = document.querySelectorAll(<span class="string">'.copy-btn'</span>);

copyBtns.forEach(btn => {
    btn.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> () => {
        <span class="keyword">const</span> textToCopy = btn.dataset.copy || btn.previousElementSibling.textContent;

        <span class="keyword">try</span> {
            <span class="keyword">await</span> navigator.clipboard.writeText(textToCopy);

            <span class="comment">// 복사 완료 피드백</span>
            <span class="keyword">const</span> originalText = btn.textContent;
            btn.textContent = <span class="string">'복사됨!'</span>;
            btn.classList.add(<span class="string">'copied'</span>);

            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove(<span class="string">'copied'</span>);
            }, <span class="number">2000</span>);
        } <span class="keyword">catch</span> (err) {
            console.error(<span class="string">'복사 실패:'</span>, err);
        }
    });
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-lock"></i></div>
                            <div class="highlight-content">
                                <h5>Clipboard API 제약</h5>
                                <p>navigator.clipboard는 보안상 제약이 있어 HTTPS 환경(또는 localhost)에서만 안정적으로 동작한다. 또한 사용자 제스처(클릭)
                                    안에서 호출되어야 한다.</p>
                                <p>실무에서는 실패 대비로 <code>document.execCommand('copy')</code> 같은 폴백을 두기도 하지만, 점점 Clipboard
                                    API 중심으로 가는 추세다.</p>
                            </div>
                        </div>
                    </div>



                    <!-- ============================================ -->
                    <!-- 3. 마우스 이벤트 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-computer-mouse"></i> 마우스 이벤트</h4>

                        <div class="info-box">
                            <p>마우스 이벤트는 커서 추적, 호버 효과, 드래그 앤 드롭 등 다양한 인터랙션에 사용된다. mousemove는 빈번하게 발생하므로
                                requestAnimationFrame이나 throttle을 활용해 성능을 최적화해야 한다.</p>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-gauge-high"></i></div>
                            <div class="highlight-content">
                                <h5>마우스 이벤트의 본질은 “연속 입력” 처리</h5>
                                <p>클릭은 이벤트가 ‘끊어져’ 발생하지만 mousemove는 ‘연속적으로’ 쏟아진다. 그래서 마우스 인터랙션은 시각 효과보다 먼저 성능과 안정성 설계가
                                    들어가야 한다.</p>
                                <p>실무 기준으로는 “이벤트에서 계산만 하고, DOM 반영은 rAF 한 번으로 묶기”, “레이아웃 값을 읽는(getBoundingClientRect 등)
                                    작업의 빈도 줄이기”, “transform 중심으로 렌더링하기”가 기본 규칙이다.</p>
                            </div>
                        </div>

                        <!-- ✅ 공통 패턴: rAF로 mousemove 최적화 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-screwdriver-wrench"></i> mousemove 최적화 기본 패턴</h4>
                            <p>mousemove 핸들러 안에서 매번 style을 바꾸면, 이벤트 발생 횟수만큼 렌더링 파이프라인이 흔들릴 수 있다. 가장 안정적인 형태는 “좌표만 저장”하고,
                                실제 렌더링은 requestAnimationFrame에서 한 번만 처리하는 구조다.</p>
                            <div class="code-block">
                                <div class="code-header">
                                    <span class="code-lang">JavaScript</span>
                                    <span class="code-title">mousemove → rAF 단일 렌더링</span>
                                </div>
                                <pre><code><span class="keyword">let</span> mx = <span class="number">0</span>, my = <span class="number">0</span>;
<span class="keyword">let</span> ticking = <span class="boolean">false</span>;

document.addEventListener(<span class="string">'mousemove'</span>, (e) => {
  mx = e.clientX;
  my = e.clientY;

  <span class="keyword">if</span> (!ticking) {
    ticking = <span class="boolean">true</span>;
    requestAnimationFrame(() => {
      <span class="comment">// 여기에서만 DOM 갱신(렌더링) 수행</span>
      <span class="comment">// update(mx, my);</span>
      ticking = <span class="boolean">false</span>;
    });
  }
});</code></pre>
                            </div>
                            <p>이 패턴을 커서/트레일/틸트/툴팁 모두에 동일하게 적용할 수 있다. “연속 입력은 저장, 렌더는 rAF”가 기본 골격이다.</p>
                        </div>

                        <!-- 커서 효과 -->
                        <h5 class="sub-title">커서 효과</h5>
                        <p class="desc-text">기본 마우스 커서 대신 커스텀 커서를 사용하거나, 마우스 위치에 반응하는 효과를 만들 수 있다. 포트폴리오, 인터랙티브 사이트에서
                            개성을 표현할 때 사용한다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>커스텀 커서에서 가장 먼저 체크할 것</h5>
                                <p>커스텀 커서는 시각적으로 강하지만, 접근성과 호환성 이슈가 자주 생긴다. 특히 (1) pointer-events: none으로 클릭을 방해하지 않기,
                                    (2) 입력 장치가 터치인 환경에서는 자동 비활성화하기, (3) 실제 커서 형태(cursor CSS)를 함께 설계하기가 기본이다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">부드럽게 따라다니는 커스텀 커서</span>
                            </div>
                            <pre><code><span class="comment">// 마우스를 부드럽게 따라다니는 커스텀 커서</span>
<span class="comment">// lerp(선형보간)으로 지연 효과 구현</span>
<span class="keyword">const</span> cursor = document.querySelector(<span class="string">'.custom-cursor'</span>);
<span class="keyword">let</span> mouseX = <span class="number">0</span>, mouseY = <span class="number">0</span>;
<span class="keyword">let</span> cursorX = <span class="number">0</span>, cursorY = <span class="number">0</span>;

document.addEventListener(<span class="string">'mousemove'</span>, (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

<span class="comment">// 부드러운 따라다니기 (requestAnimationFrame 활용)</span>
<span class="keyword">function</span> <span class="function">animateCursor</span>() {
    <span class="comment">// 0.1 = 지연 정도 (작을수록 느림)</span>
    cursorX += (mouseX - cursorX) * <span class="number">0.1</span>;
    cursorY += (mouseY - cursorY) * <span class="number">0.1</span>;
    cursor.style.transform = <span class="string">`translate(</span><span class="interpolation">${cursorX}</span><span class="string">px, </span><span class="interpolation">${cursorY}</span><span class="string">px)`</span>;
    requestAnimationFrame(animateCursor);
}
animateCursor();

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .custom-cursor {</span>
<span class="comment">//   position: fixed; top: 0; left: 0;</span>
<span class="comment">//   width: 20px; height: 20px;</span>
<span class="comment">//   border-radius: 50%;</span>
<span class="comment">//   background: rgba(0,0,0,0.5);</span>
<span class="comment">//   pointer-events: none; /* 클릭 방해 안 함 */</span>
<span class="comment">//   z-index: 9999;</span>
<span class="comment">// }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-wave-square"></i> lerp(선형 보간)이 “부드러움”을 만드는 이유</h4>
                            <p>이 코드는 커서를 마우스 좌표에 ‘즉시’ 붙이지 않고, 목표점으로 조금씩 따라가게 만든다. 즉, 위치 변화가 계단처럼 튀지 않고
                                “잔상(지연)”으로 느껴진다. 0.1 값은 매 프레임마다 목표 거리의 10%만 이동한다는 뜻이라, 값이 작을수록 더 느리고 무거운 느낌이 난다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">호버 시 커서 확대</span>
                            </div>
                            <pre><code><span class="comment">// 링크나 버튼 위에서 커서가 커지는 효과</span>
<span class="keyword">const</span> cursor = document.querySelector(<span class="string">'.custom-cursor'</span>);
<span class="keyword">const</span> hoverTargets = document.querySelectorAll(<span class="string">'a, button, .hover-target'</span>);

hoverTargets.forEach(target => {
    target.addEventListener(<span class="string">'mouseenter'</span>, () => {
        cursor.classList.add(<span class="string">'cursor-hover'</span>);
    });
    target.addEventListener(<span class="string">'mouseleave'</span>, () => {
        cursor.classList.remove(<span class="string">'cursor-hover'</span>);
    });
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .custom-cursor { transition: transform 0.3s, width 0.3s, height 0.3s; }</span>
<span class="comment">// .custom-cursor.cursor-hover { width: 50px; height: 50px; mix-blend-mode: difference; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-link"></i></div>
                            <div class="highlight-content">
                                <h5>호버 확대는 “상태 신호”</h5>
                                <p>이 효과는 장식이 아니라 ‘여기가 상호작용 가능한 요소’라는 신호를 강화한다. 그래서 hoverTargets를 a/button 같은 인터랙션 요소로 묶는
                                    것이 논리적으로 맞다.</p>
                                <p>또한 mix-blend-mode는 배경에 따라 대비가 달라질 수 있으니, 실무에서는 테마/배경에 맞게 제한적으로 쓰거나 폴백을 둔다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">마우스 트레일 효과</span>
                            </div>
                            <pre><code><span class="comment">// 마우스 뒤에 꼬리처럼 따라오는 점들</span>
<span class="keyword">const</span> trailCount = <span class="number">20</span>;
<span class="keyword">const</span> trails = [];

<span class="comment">// 트레일 요소 생성</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < trailCount; i++) {
    <span class="keyword">const</span> trail = document.createElement(<span class="string">'div'</span>);
    trail.className = <span class="string">'trail'</span>;
    trail.style.opacity = <span class="number">1</span> - (i / trailCount);  <span class="comment">// 뒤로 갈수록 투명</span>
    document.body.appendChild(trail);
    trails.push({ el: trail, x: <span class="number">0</span>, y: <span class="number">0</span> });
}

document.addEventListener(<span class="string">'mousemove'</span>, (e) => {
    trails[<span class="number">0</span>].x = e.clientX;
    trails[<span class="number">0</span>].y = e.clientY;
});

<span class="keyword">function</span> <span class="function">animateTrails</span>() {
    <span class="keyword">for</span> (<span class="keyword">let</span> i = trails.length - <span class="number">1</span>; i > <span class="number">0</span>; i--) {
        <span class="comment">// 앞의 점을 따라감</span>
        trails[i].x += (trails[i-<span class="number">1</span>].x - trails[i].x) * <span class="number">0.3</span>;
        trails[i].y += (trails[i-<span class="number">1</span>].y - trails[i].y) * <span class="number">0.3</span>;
    }

    trails.forEach(trail => {
        trail.el.style.transform = <span class="string">`translate(</span><span class="interpolation">${trail.x}</span><span class="string">px, </span><span class="interpolation">${trail.y}</span><span class="string">px)`</span>;
    });

    requestAnimationFrame(animateTrails);
}
animateTrails();</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-battery-half"></i></div>
                            <div class="highlight-content">
                                <h5>트레일은 성능 비용이 크다</h5>
                                <p>trailCount만큼 DOM 요소가 계속 transform 갱신을 받는다. 데스크톱에서는 괜찮아도 저사양 기기/배터리 환경에서는 체감이 크게 떨어질 수
                                    있다.</p>
                                <p>실무에서는 (1) trailCount를 낮추거나, (2) 화면 밖에서는 중단하거나, (3) canvas로 옮겨 렌더링 비용을 줄이는 방식으로 조정한다.
                                </p>
                            </div>
                        </div>

                        <!-- 3D 효과 -->
                        <h5 class="sub-title">3D 효과 및 마우스 반응</h5>
                        <p class="desc-text">마우스 위치에 따라 요소가 기울어지거나, 빛 효과가 따라다니는 등의 3D 인터랙션이다. 카드 UI, 제품 소개 등에서 고급스러운 느낌을
                            준다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-cube"></i> 3D 반응의 핵심은 “기준 좌표계”</h4>
                            <p>카드 틸트/글로우 효과는 모두 “요소 내부에서의 마우스 위치(x,y)”를 구한 뒤, 그 값을 회전/그라데이션 기준으로 변환하는 구조다.</p>
                            <p>즉, getBoundingClientRect로 요소의 좌표계(rect)를 얻고, clientX/clientY를 rect 기준으로 재계산하는 단계가 핵심이다.
                                이 좌표 변환이 흔들리면 틸트가 어색해지고, 빛 위치도 튄다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">카드 틸트 효과 (3D 기울어짐)</span>
                            </div>
                            <pre><code><span class="comment">// 마우스 위치에 따라 카드가 기울어지는 3D 효과</span>
<span class="comment">// 카드 UI, 제품 소개에서 임팩트 있는 표현</span>
<span class="keyword">const</span> cards = document.querySelectorAll(<span class="string">'.tilt-card'</span>);

cards.forEach(card => {
    card.addEventListener(<span class="string">'mousemove'</span>, (e) => {
        <span class="keyword">const</span> rect = card.getBoundingClientRect();
        <span class="keyword">const</span> x = e.clientX - rect.left;  <span class="comment">// 카드 내 X 위치</span>
        <span class="keyword">const</span> y = e.clientY - rect.top;   <span class="comment">// 카드 내 Y 위치</span>
        <span class="keyword">const</span> centerX = rect.width / <span class="number">2</span>;
        <span class="keyword">const</span> centerY = rect.height / <span class="number">2</span>;

        <span class="comment">// 중심에서 얼마나 떨어졌는지에 따라 회전 각도 계산</span>
        <span class="keyword">const</span> rotateX = (y - centerY) / <span class="number">10</span>;  <span class="comment">// 10 = 민감도</span>
        <span class="keyword">const</span> rotateY = (centerX - x) / <span class="number">10</span>;

        card.style.transform = <span class="string">`perspective(1000px)
            rotateX(</span><span class="interpolation">${rotateX}</span><span class="string">deg) rotateY(</span><span class="interpolation">${rotateY}</span><span class="string">deg)`</span>;
    });

    <span class="comment">// 마우스 떠나면 원래 상태로</span>
    card.addEventListener(<span class="string">'mouseleave'</span>, () => {
        card.style.transform = <span class="string">'perspective(1000px) rotateX(0) rotateY(0)'</span>;
    });
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .tilt-card { transition: transform 0.1s ease; transform-style: preserve-3d; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>틸트에서 getBoundingClientRect를 매번 호출하는 비용</h5>
                                <p>mousemove 안에서 rect를 매번 읽으면 비용이 누적될 수 있다. 카드가 많거나, 틸트 대상이 큰 페이지에서는 “mouseenter 때 rect를
                                    캐시하고, resize/scroll 때만 갱신”하는 방식이 더 안정적이다.</p>
                                <p>교육용 예제에서는 원리 설명이 명확하지만, 실무로 가져갈 때는 캐시 전략을 붙이는 편이 좋다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">마우스 따라다니는 빛 효과</span>
                            </div>
                            <pre><code><span class="comment">// 카드 위에서 마우스 위치에 빛 효과가 따라다님</span>
<span class="keyword">const</span> glowCards = document.querySelectorAll(<span class="string">'.glow-card'</span>);

glowCards.forEach(card => {
    card.addEventListener(<span class="string">'mousemove'</span>, (e) => {
        <span class="keyword">const</span> rect = card.getBoundingClientRect();
        <span class="keyword">const</span> x = e.clientX - rect.left;
        <span class="keyword">const</span> y = e.clientY - rect.top;

        <span class="comment">// CSS 변수로 마우스 위치 전달</span>
        card.style.setProperty(<span class="string">'--mouse-x'</span>, x + <span class="string">'px'</span>);
        card.style.setProperty(<span class="string">'--mouse-y'</span>, y + <span class="string">'px'</span>);
    });
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .glow-card::before {</span>
<span class="comment">//   content: ''; position: absolute;</span>
<span class="comment">//   width: 200px; height: 200px;</span>
<span class="comment">//   background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);</span>
<span class="comment">//   left: var(--mouse-x); top: var(--mouse-y);</span>
<span class="comment">//   transform: translate(-50%, -50%);</span>
<span class="comment">//   opacity: 0; transition: opacity 0.3s;</span>
<span class="comment">// }</span>
<span class="comment">// .glow-card:hover::before { opacity: 1; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-sliders"></i> CSS 변수 전달 방식의 장점</h4>
                            <p>JS가 직접 ::before 스타일을 건드릴 수 없기 때문에, 좌표만 CSS 변수로 전달하고 실제 표현은 CSS에서 맡기는 구조가 깔끔하다.</p>
                            <p>이 방식은 “입력(좌표)과 출력(표현)”이 분리되어 유지보수성이 높고, 디자이너/퍼블리셔가 CSS에서 질감을 바꾸기도 쉽다.</p>
                        </div>

                        <!-- 이미지 효과 -->
                        <h5 class="sub-title">이미지 관련 효과</h5>
                        <p class="desc-text">이미지 확대, 비교 슬라이더 등 이미지에 적용하는 마우스 인터랙션이다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-magnifying-glass-plus"></i></div>
                            <div class="highlight-content">
                                <h5>이미지 인터랙션은 “사용자 통제감”이 핵심</h5>
                                <p>줌/비교는 시각적으로 화려하지만, 사용자가 원하지 않으면 방해가 된다. 그래서 hover 기반이면 “mouseleave 시 원상복귀”가 필수고,
                                    드래그 기반이면 “현재 위치가 어디인지”를 손잡이(handle)로 명확히 보여줘야 한다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">마우스 위치 기반 이미지 줌</span>
                            </div>
                            <pre><code><span class="comment">// 쇼핑몰 제품 이미지 확대 효과</span>
<span class="comment">// 마우스 위치 기준으로 확대</span>
<span class="keyword">const</span> zoomContainer = document.querySelector(<span class="string">'.zoom-container'</span>);
<span class="keyword">const</span> zoomImage = zoomContainer.querySelector(<span class="string">'img'</span>);

zoomContainer.addEventListener(<span class="string">'mousemove'</span>, (e) => {
    <span class="keyword">const</span> rect = zoomContainer.getBoundingClientRect();
    <span class="comment">// 마우스 위치를 0~100% 로 변환</span>
    <span class="keyword">const</span> x = ((e.clientX - rect.left) / rect.width) * <span class="number">100</span>;
    <span class="keyword">const</span> y = ((e.clientY - rect.top) / rect.height) * <span class="number">100</span>;

    <span class="comment">// 마우스 위치를 기준점으로 확대</span>
    zoomImage.style.transformOrigin = <span class="string">`</span><span class="interpolation">${x}</span><span class="string">% </span><span class="interpolation">${y}</span><span class="string">%`</span>;
    zoomImage.style.transform = <span class="string">'scale(2)'</span>;  <span class="comment">// 2배 확대</span>
});

zoomContainer.addEventListener(<span class="string">'mouseleave'</span>, () => {
    zoomImage.style.transform = <span class="string">'scale(1)'</span>;
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .zoom-container { overflow: hidden; }</span>
<span class="comment">// .zoom-container img { transition: transform 0.3s ease; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-crosshairs"></i> transform-origin을 쓰는 이유</h4>
                            <p>scale만 하면 이미지가 중앙 기준으로 커지는데, 제품 확대는 사용자가 보고 있는 지점이 ‘확대 중심’이 되어야 한다. 그래서 마우스 좌표를 0~100%로
                                바꿔
                                transform-origin으로 전달한다. 결과적으로 “마우스 아래의 디테일이 확대”되는 느낌이 나온다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">이미지 비교 슬라이더</span>
                            </div>
                            <pre><code><span class="comment">// Before/After 이미지 비교 슬라이더</span>
<span class="comment">// 드래그하거나 마우스 이동으로 비교</span>
<span class="keyword">const</span> slider = document.querySelector(<span class="string">'.image-compare'</span>);
<span class="keyword">const</span> beforeImg = slider.querySelector(<span class="string">'.before'</span>);
<span class="keyword">const</span> handle = slider.querySelector(<span class="string">'.handle'</span>);

<span class="keyword">function</span> <span class="function">updateSlider</span>(x) {
    <span class="keyword">const</span> rect = slider.getBoundingClientRect();
    <span class="keyword">let</span> percent = ((x - rect.left) / rect.width) * <span class="number">100</span>;
    percent = Math.max(<span class="number">0</span>, Math.min(<span class="number">100</span>, percent));  <span class="comment">// 0~100 제한</span>

    beforeImg.style.clipPath = <span class="string">`inset(0 </span><span class="interpolation">${100 - percent}</span><span class="string">% 0 0)`</span>;
    handle.style.left = percent + <span class="string">'%'</span>;
}

<span class="comment">// 마우스 이동으로 조절</span>
slider.addEventListener(<span class="string">'mousemove'</span>, (e) => updateSlider(e.clientX));

<span class="comment">// 터치 지원</span>
slider.addEventListener(<span class="string">'touchmove'</span>, (e) => {
    updateSlider(e.touches[<span class="number">0</span>].clientX);
});

<span class="comment">/* HTML 구조 */</span>
<span class="comment">// &lt;div class="image-compare"&gt;</span>
<span class="comment">//   &lt;img class="after" src="after.jpg"&gt;</span>
<span class="comment">//   &lt;img class="before" src="before.jpg"&gt;</span>
<span class="comment">//   &lt;div class="handle"&gt;&lt;/div&gt;</span>
<span class="comment">// &lt;/div&gt;</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-hand"></i></div>
                            <div class="highlight-content">
                                <h5>“mousemove로만” 비교 슬라이더를 만들 때 생기는 문제</h5>
                                <p>마우스가 슬라이더 위를 지나가기만 해도 값이 바뀌기 때문에, 사용자가 의도하지 않은 조작이 발생할 수 있다. 실무에서는 “mousedown 중에만
                                    움직이게”
                                    하거나, handle을 드래그할 때만 반응하도록 제한하는 방식이 더 많다.</p>
                            </div>
                        </div>

                        <!-- 드래그 앤 드롭 -->
                        <h5 class="sub-title">드래그 앤 드롭</h5>
                        <p class="desc-text">요소를 끌어서 다른 위치로 이동시키는 기능이다. 파일 업로드, 리스트 정렬, 칸반 보드 등에서 사용된다. HTML5 Drag and
                            Drop API를 활용한다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-grip"></i> HTML5 Drag & Drop API vs 커스텀 드래그</h4>
                            <p>HTML5 Drag & Drop은 “데스크톱 파일/요소 드래그”에는 편하지만, 모바일 터치나 세밀한 제어(관성, 제한 영역, 드래그 프리뷰 커스터마이징)에서는
                                한계가 있다.</p>
                            <p>그래서 실무에서는 파일 업로드는 HTML5 API를 쓰고, 리스트 정렬/칸반 이동 같은 UI 드래그는 Pointer Events 기반 커스텀 드래그를 쓰는
                                경우가 많다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 드래그 앤 드롭</span>
                            </div>
                            <pre><code><span class="comment">// 드래그 가능한 요소를 드롭 존으로 이동</span>
<span class="keyword">const</span> draggables = document.querySelectorAll(<span class="string">'.draggable'</span>);
<span class="keyword">const</span> dropZones = document.querySelectorAll(<span class="string">'.drop-zone'</span>);

<span class="comment">// 드래그 가능한 요소 설정</span>
draggables.forEach(item => {
    item.setAttribute(<span class="string">'draggable'</span>, <span class="string">'true'</span>);

    item.addEventListener(<span class="string">'dragstart'</span>, (e) => {
        item.classList.add(<span class="string">'dragging'</span>);
        e.dataTransfer.setData(<span class="string">'text/plain'</span>, item.id);
        e.dataTransfer.effectAllowed = <span class="string">'move'</span>;
    });

    item.addEventListener(<span class="string">'dragend'</span>, () => {
        item.classList.remove(<span class="string">'dragging'</span>);
    });
});

<span class="comment">// 드롭 존 설정</span>
dropZones.forEach(zone => {
    zone.addEventListener(<span class="string">'dragover'</span>, (e) => {
        e.preventDefault();  <span class="comment">// 드롭 허용 (필수)</span>
        zone.classList.add(<span class="string">'drag-over'</span>);
    });

    zone.addEventListener(<span class="string">'dragleave'</span>, () => {
        zone.classList.remove(<span class="string">'drag-over'</span>);
    });

    zone.addEventListener(<span class="string">'drop'</span>, (e) => {
        e.preventDefault();
        <span class="keyword">const</span> id = e.dataTransfer.getData(<span class="string">'text/plain'</span>);
        <span class="keyword">const</span> dragged = document.getElementById(id);
        zone.appendChild(dragged);
        zone.classList.remove(<span class="string">'drag-over'</span>);
    });
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-check"></i></div>
                            <div class="highlight-content">
                                <h5>dragover에서 preventDefault가 “필수”인 이유</h5>
                                <p>브라우저 기본 동작은 드롭을 허용하지 않는다. 그래서 dragover에서 preventDefault를 하지 않으면 drop 이벤트 자체가 발생하지
                                    않는다.</p>
                                <p>이 한 줄이 빠져서 “왜 drop이 안 되지?”가 가장 흔한 디버깅 포인트다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">리스트 순서 변경 (Sortable)</span>
                            </div>
                            <pre><code><span class="comment">// 리스트 아이템 순서를 드래그로 변경</span>
<span class="keyword">const</span> sortableList = document.querySelector(<span class="string">'.sortable-list'</span>);

sortableList.addEventListener(<span class="string">'dragstart'</span>, (e) => {
    e.target.classList.add(<span class="string">'dragging'</span>);
});

sortableList.addEventListener(<span class="string">'dragend'</span>, (e) => {
    e.target.classList.remove(<span class="string">'dragging'</span>);
});

sortableList.addEventListener(<span class="string">'dragover'</span>, (e) => {
    e.preventDefault();
    <span class="keyword">const</span> dragging = sortableList.querySelector(<span class="string">'.dragging'</span>);
    <span class="keyword">const</span> siblings = [...sortableList.querySelectorAll(<span class="string">'.sortable-item:not(.dragging)'</span>)];

    <span class="comment">// 마우스 위치에 가장 가까운 요소 찾기</span>
    <span class="keyword">const</span> nextSibling = siblings.find(sibling => {
        <span class="keyword">const</span> box = sibling.getBoundingClientRect();
        <span class="keyword">return</span> e.clientY < box.top + box.height / <span class="number">2</span>;
    });

    sortableList.insertBefore(dragging, nextSibling);
});</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>Sortable의 체감 품질 포인트</h5>
                                <p>이 방식은 단순하지만, 리스트가 길어질수록 dragover에서 getBoundingClientRect를 많이 호출하게 된다. 항목 수가 많으면 체감
                                    지연이 생길 수 있다.</p>
                                <p>실무에서는 (1) placeholder를 두고 위치 계산을 줄이거나, (2) requestAnimationFrame으로 dragover 렌더를 묶거나,
                                    (3) 아예 검증된 라이브러리(SortableJS 등)를 쓰는 편이 많다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">파일 드래그 앤 드롭 업로드</span>
                            </div>
                            <pre><code><span class="comment">// 파일을 드래그해서 업로드하는 영역</span>
<span class="keyword">const</span> dropArea = document.querySelector(<span class="string">'.drop-area'</span>);

<span class="comment">// 기본 동작 방지</span>
[<span class="string">'dragenter'</span>, <span class="string">'dragover'</span>, <span class="string">'dragleave'</span>, <span class="string">'drop'</span>].forEach(event => {
    dropArea.addEventListener(event, (e) => {
        e.preventDefault();
        e.stopPropagation();
    });
});

<span class="comment">// 드래그 중 스타일</span>
[<span class="string">'dragenter'</span>, <span class="string">'dragover'</span>].forEach(event => {
    dropArea.addEventListener(event, () => dropArea.classList.add(<span class="string">'highlight'</span>));
});
[<span class="string">'dragleave'</span>, <span class="string">'drop'</span>].forEach(event => {
    dropArea.addEventListener(event, () => dropArea.classList.remove(<span class="string">'highlight'</span>));
});

<span class="comment">// 파일 드롭 처리</span>
dropArea.addEventListener(<span class="string">'drop'</span>, (e) => {
    <span class="keyword">const</span> files = e.dataTransfer.files;
    handleFiles(files);
});

<span class="keyword">function</span> <span class="function">handleFiles</span>(files) {
    [...files].forEach(file => {
        console.log(<span class="string">'파일명:'</span>, file.name);
        console.log(<span class="string">'크기:'</span>, file.size);
        console.log(<span class="string">'타입:'</span>, file.type);
        <span class="comment">// FormData로 서버에 업로드하거나 미리보기 표시</span>
    });
}</code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-shield-halved"></i> 파일 드롭은 “브라우저 기본 동작 차단”이 먼저</h4>
                            <p>기본 동작을 막지 않으면 브라우저가 파일을 새 탭으로 열어버리는 등, 사용자가 작업하던 페이지 맥락이 깨진다. 그래서 dragenter~drop까지 전 구간에서
                                preventDefault/stopPropagation을 먼저 처리한다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">마우스로 직접 드래그 (커스텀)</span>
                            </div>
                            <pre><code><span class="comment">// HTML5 API 대신 마우스 이벤트로 직접 구현</span>
<span class="comment">// 더 세밀한 제어가 필요할 때 사용</span>
<span class="keyword">const</span> draggable = document.querySelector(<span class="string">'.custom-drag'</span>);
<span class="keyword">let</span> isDragging = <span class="boolean">false</span>;
<span class="keyword">let</span> offsetX, offsetY;

draggable.addEventListener(<span class="string">'mousedown'</span>, (e) => {
    isDragging = <span class="boolean">true</span>;
    offsetX = e.clientX - draggable.offsetLeft;
    offsetY = e.clientY - draggable.offsetTop;
    draggable.classList.add(<span class="string">'dragging'</span>);
});

document.addEventListener(<span class="string">'mousemove'</span>, (e) => {
    <span class="keyword">if</span> (!isDragging) <span class="keyword">return</span>;

    <span class="keyword">const</span> x = e.clientX - offsetX;
    <span class="keyword">const</span> y = e.clientY - offsetY;

    draggable.style.left = x + <span class="string">'px'</span>;
    draggable.style.top = y + <span class="string">'px'</span>;
});

document.addEventListener(<span class="string">'mouseup'</span>, () => {
    isDragging = <span class="boolean">false</span>;
    draggable.classList.remove(<span class="string">'dragging'</span>);
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .custom-drag { position: absolute; cursor: grab; }</span>
<span class="comment">// .custom-drag.dragging { cursor: grabbing; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-hand-pointer"></i></div>
                            <div class="highlight-content">
                                <h5>커스텀 드래그는 Pointer Events로 확장하는 게 정석</h5>
                                <p>mousedown/mousemove/mouseup은 터치에서 대응이 애매하다. 실무에서는 pointerdown/pointermove/pointerup으로
                                    바꾸면 마우스/터치를 통합할 수 있다.</p>
                                <p>또한 드래그 중에는 텍스트 선택이 생길 수 있으니 user-select: none 처리나, 드래그 시작 시점에 preventDefault를 함께
                                    고려한다.</p>
                            </div>
                        </div>

                        <!-- 툴팁 -->
                        <h5 class="sub-title">툴팁 및 팝오버</h5>
                        <p class="desc-text">마우스를 올리면 추가 정보가 나타나는 툴팁이다. 아이콘 설명, 용어 정의 등에 활용된다.</p>

                        <!-- ✅ 설명 추가 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-comment-dots"></i> 툴팁의 핵심은 “위치 안정성”</h4>
                            <p>툴팁은 마우스를 따라다니면 직관적이지만, 화면 끝에서 잘리거나(overflow) 포인터가 툴팁 위로 올라가면서 깜빡이는 문제가 생길 수 있다.</p>
                            <p>그래서 pointer-events: none, viewport 경계 보정(좌표 클램프), 필요 시 딜레이(enter 150ms 정도)를 넣어서 흔들림을 줄인다.
                            </p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">마우스 위치에 따라다니는 툴팁</span>
                            </div>
                            <pre><code><span class="comment">// 마우스 위치를 따라다니는 커스텀 툴팁</span>
<span class="keyword">const</span> tooltip = document.querySelector(<span class="string">'.tooltip'</span>);
<span class="keyword">const</span> tooltipTargets = document.querySelectorAll(<span class="string">'[data-tooltip]'</span>);

tooltipTargets.forEach(target => {
    target.addEventListener(<span class="string">'mouseenter'</span>, (e) => {
        tooltip.textContent = target.dataset.tooltip;
        tooltip.classList.add(<span class="string">'visible'</span>);
    });

    target.addEventListener(<span class="string">'mousemove'</span>, (e) => {
        tooltip.style.left = (e.clientX + <span class="number">15</span>) + <span class="string">'px'</span>;
        tooltip.style.top = (e.clientY + <span class="number">15</span>) + <span class="string">'px'</span>;
    });

    target.addEventListener(<span class="string">'mouseleave'</span>, () => {
        tooltip.classList.remove(<span class="string">'visible'</span>);
    });
});

<span class="comment">/* HTML 예시 */</span>
<span class="comment">// &lt;span data-tooltip="이것은 설명입니다"&gt;호버하세요&lt;/span&gt;</span>
<span class="comment">// &lt;div class="tooltip"&gt;&lt;/div&gt;</span>

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .tooltip { position: fixed; opacity: 0; pointer-events: none; }</span>
<span class="comment">// .tooltip.visible { opacity: 1; }</span></code></pre>
                        </div>

                        <!-- ✅ 설명 추가: 경계 보정 팁 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-border-top-left"></i></div>
                            <div class="highlight-content">
                                <h5>툴팁 경계 보정(잘림 방지) 아이디어</h5>
                                <p>툴팁이 화면 밖으로 나가면 읽기 어려워진다. 실무에서는 tooltip의 폭/높이를 읽고, clientX/clientY를 기준으로 “최대값을 제한”한다.
                                </p>
                                <p>원리는 단순하다. left/top를 그대로 쓰지 말고, (viewport - tooltipSize) 범위 안으로 clamp하는 방식이다. 필요하면 rAF
                                    패턴까지 결합한다.</p>
                            </div>
                        </div>
                    </div>


                    <!-- ============================================ -->
                    <!-- 4. 키보드 이벤트 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-keyboard"></i> 키보드 이벤트</h4>

                        <div class="info-box">
                            <p>키보드 이벤트는 단축키, 검색, 게임, 폼 입력 등에서 사용된다. 접근성을 위해 마우스로만 동작하는 기능에 키보드 대안을 제공하는 것이 좋다. keydown,
                                keyup, keypress(deprecated) 이벤트가 있다.</p>
                        </div>

                        <!-- ✅ 설명 보강 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-universal-access"></i></div>
                            <div class="highlight-content">
                                <h5>키보드 이벤트의 실무 의미</h5>
                                <p>키보드는 “편의 기능”이기도 하지만, 접근성 관점에서는 “동등한 조작 채널”이다. 마우스로만 가능한 기능은 실제로는 UI 기능의 일부가 막혀 있는 상태와
                                    같다.</p>
                                <p>또한 키보드 입력은 브라우저/OS 단축키와 충돌할 수 있으므로, (1) 전역 단축키는 최소화하고, (2) 앱 내부 컨텍스트에서만 활성화하며, (3) 입력
                                    필드에서는 단축키를 억제하는 설계가 기본이다.</p>
                            </div>
                        </div>

                        <div class="content-card">
                            <h4><i class="fa-solid fa-triangle-exclamation"></i> keydown / keyup / keypress 차이</h4>
                            <p><strong>keydown</strong>은 키를 누르는 순간 발생하며, 길게 누르면 반복 발생한다(키 반복). 대부분의 단축키/네비게이션은 keydown
                                기반으로 처리한다.</p>
                            <p><strong>keyup</strong>은 키에서 손을 떼는 순간 발생한다. “누르고 있는 동안” 상태를 종료하거나, 입력 확정 타이밍을 잡는 데 사용한다.
                            </p>
                            <p><strong>keypress</strong>는 문자 입력 중심 이벤트였고, 현재는 deprecated다. 실무에서는 keydown/keyup을 사용하고,
                                텍스트 입력 변화는 input 이벤트로 분리한다.</p>
                        </div>

                        <!-- ✅ 공통 가드(입력창/IME/중복 실행 방지) -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-shield"></i> 단축키 설계의 공통 가드</h4>
                            <p>단축키 코드는 기능 자체보다 “언제 무시해야 하는가”가 더 중요하다. 최소한 아래 조건은 기본으로 걸어두는 편이 안전하다.</p>

                            <div class="code-block">
                                <div class="code-header">
                                    <span class="code-lang">JavaScript</span>
                                    <span class="code-title">단축키 공통 가드(입력 필드/IME/키 반복)</span>
                                </div>
                                <pre><code><span class="keyword">function</span> <span class="function">isTypingContext</span>(target) {
  <span class="keyword">if</span> (!target) <span class="keyword">return</span> <span class="boolean">false</span>;
  <span class="keyword">const</span> tag = (target.tagName || <span class="string">''</span>).toLowerCase();
  <span class="keyword">return</span> tag === <span class="string">'input'</span> || tag === <span class="string">'textarea'</span> || target.isContentEditable;
}

document.addEventListener(<span class="string">'keydown'</span>, (e) => {
  <span class="comment">// 1) IME 조합 중(한글 입력 등)에는 단축키를 건드리지 않는 편이 안전</span>
  <span class="keyword">if</span> (e.isComposing) <span class="keyword">return</span>;

  <span class="comment">// 2) 입력 컨텍스트에서는 전역 단축키를 기본적으로 무시</span>
  <span class="keyword">if</span> (isTypingContext(e.target)) <span class="keyword">return</span>;

  <span class="comment">// 3) keydown 반복(길게 누름) 때문에 중복 실행이 문제면 차단</span>
  <span class="keyword">if</span> (e.repeat) <span class="keyword">return</span>;

  <span class="comment">// ...여기부터 단축키 처리</span>
});</code></pre>
                            </div>
                        </div>

                        <h5 class="sub-title">단축키 구현</h5>
                        <p class="desc-text">Ctrl, Alt, Shift와 조합한 단축키를 구현한다. 웹 앱에서 생산성을 높이는 핵심 기능이다.</p>

                        <!-- ✅ 설명 보강 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-key"></i></div>
                            <div class="highlight-content">
                                <h5>브라우저/OS 단축키 충돌이 빈번한 조합</h5>
                                <p>Ctrl+S, Ctrl+P, Ctrl+L, Ctrl+W 같은 조합은 브라우저 기본 동작이 강하다. 앱 단축키로 쓰려면 preventDefault가
                                    필요하지만, 사용자가 기대하는 기본 동작을 빼앗는 부작용도 생긴다.</p>
                                <p>실무에서는 “앱 내부 문서 편집/디자인 툴”처럼 맥락이 분명할 때만 강한 단축키를 쓰고, 일반 웹페이지에서는 Ctrl+K(검색), /(검색) 같은 비교적
                                    안전한 단축키가 더 흔하다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 단축키</span>
                            </div>
                            <pre><code><span class="comment">// Ctrl+S: 저장, Ctrl+K: 검색 등 단축키 구현</span>
document.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="comment">// Ctrl + S: 저장</span>
    <span class="keyword">if</span> (e.ctrlKey && e.key === <span class="string">'s'</span>) {
        e.preventDefault();  <span class="comment">// 브라우저 기본 저장 방지</span>
        saveDocument();
    }

    <span class="comment">// Ctrl + K: 검색창 열기</span>
    <span class="keyword">if</span> (e.ctrlKey && e.key === <span class="string">'k'</span>) {
        e.preventDefault();
        openSearchModal();
    }

    <span class="comment">// Esc: 모달 닫기</span>
    <span class="keyword">if</span> (e.key === <span class="string">'Escape'</span>) {
        closeAllModals();
    }

    <span class="comment">// Ctrl + Shift + P: 명령 팔레트</span>
    <span class="keyword">if</span> (e.ctrlKey && e.shiftKey && e.key === <span class="string">'P'</span>) {
        e.preventDefault();
        openCommandPalette();
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 보강 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-code-branch"></i> 단축키는 “전역”보다 “상태 기반”이 안전</h4>
                            <p>단축키는 document 전체에서 듣는 전역 방식이 편하지만, 기능이 늘수록 충돌과 오작동이 생긴다. 그래서 보통은 “모달이 열려 있을 때”, “에디터 포커스일
                                때”처럼
                                특정 상태에서만 동작하도록 가드를 둔다.</p>
                            <p>예: 검색 모달이 열려 있으면 ArrowUp/Down은 자동완성 리스트 이동으로 쓰고, 평상시에는 페이지 스크롤로 놔두는 식이다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">단축키 매니저</span>
                            </div>
                            <pre><code><span class="comment">// 단축키를 체계적으로 관리하는 매니저</span>
<span class="keyword">const</span> shortcuts = {
    <span class="string">'ctrl+s'</span>: saveDocument,
    <span class="string">'ctrl+k'</span>: openSearch,
    <span class="string">'ctrl+shift+p'</span>: openCommandPalette,
    <span class="string">'escape'</span>: closeModal,
    <span class="string">'ctrl+z'</span>: undo,
    <span class="string">'ctrl+shift+z'</span>: redo,
};

document.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="comment">// 키 조합 문자열 생성</span>
    <span class="keyword">let</span> key = <span class="string">''</span>;
    <span class="keyword">if</span> (e.ctrlKey) key += <span class="string">'ctrl+'</span>;
    <span class="keyword">if</span> (e.shiftKey) key += <span class="string">'shift+'</span>;
    <span class="keyword">if</span> (e.altKey) key += <span class="string">'alt+'</span>;
    key += e.key.toLowerCase();

    <span class="comment">// 등록된 단축키 실행</span>
    <span class="keyword">if</span> (shortcuts[key]) {
        e.preventDefault();
        shortcuts[key]();
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 보강 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-list-check"></i></div>
                            <div class="highlight-content">
                                <h5>매니저 패턴의 확장 포인트</h5>
                                <p>단축키가 많아지면 “스코프(scope)”와 “우선순위(priority)”가 필요해진다. 예를 들어 모달이 열려 있으면 모달 단축키가 전역 단축키보다
                                    우선해야 한다.</p>
                                <p>실무에서는 shortcuts를 단일 객체로 끝내지 않고, <strong>stack(스택)</strong> 형태로 쌓아 현재 활성 컨텍스트가 최상단에서
                                    단축키를 소비하도록 만든다.</p>
                            </div>
                        </div>

                        <!-- ✅ 스코프 단축키(스택 방식) -->
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">컨텍스트 스택 기반 단축키(모달 우선 처리)</span>
                            </div>
                            <pre><code><span class="comment">// 스코프 단축키: 모달/에디터 등 "현재 컨텍스트"가 우선 처리</span>
<span class="keyword">const</span> shortcutStack = [];

<span class="keyword">function</span> <span class="function">pushShortcuts</span>(map) { shortcutStack.push(map); }
<span class="keyword">function</span> <span class="function">popShortcuts</span>() { shortcutStack.pop(); }

<span class="keyword">function</span> <span class="function">combo</span>(e) {
  <span class="keyword">let</span> key = <span class="string">''</span>;
  <span class="keyword">if</span> (e.ctrlKey) key += <span class="string">'ctrl+'</span>;
  <span class="keyword">if</span> (e.shiftKey) key += <span class="string">'shift+'</span>;
  <span class="keyword">if</span> (e.altKey) key += <span class="string">'alt+'</span>;
  key += e.key.toLowerCase();
  <span class="keyword">return</span> key;
}

document.addEventListener(<span class="string">'keydown'</span>, (e) => {
  <span class="keyword">if</span> (e.isComposing) <span class="keyword">return</span>;

  <span class="comment">// 최상단 컨텍스트부터 처리 시도</span>
  <span class="keyword">const</span> k = combo(e);
  <span class="keyword">for</span> (<span class="keyword">let</span> i = shortcutStack.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
    <span class="keyword">const</span> map = shortcutStack[i];
    <span class="keyword">if</span> (map[k]) {
      e.preventDefault();
      map[k]();
      <span class="keyword">return</span>;
    }
  }
});

<span class="comment">// 예: 모달 열릴 때 push, 닫힐 때 pop</span>
<span class="comment">// pushShortcuts({ 'escape': closeModal, 'enter': confirm });</span></code></pre>
                        </div>

                        <h5 class="sub-title">방향키 네비게이션</h5>
                        <p class="desc-text">리스트, 갤러리, 슬라이드쇼 등에서 방향키로 이동하는 기능이다.</p>

                        <!-- ✅ 설명 보강 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-location-crosshairs"></i> 방향키 네비게이션에서 “포커스”가 핵심</h4>
                            <p>키보드 네비게이션은 선택 상태(selected)만 바꾸면 끝이 아니라, 실제로 사용자의 포커스가 어디 있는지를 설계해야 한다.</p>
                            <p>가능하면 roving tabindex(한 항목만 tabindex=0 유지) 패턴을 쓰면 스크린리더와 키보드 조작이 자연스럽다. 아래 예제는 현재 구조를
                                유지하면서도 scrollIntoView로 가시성을 확보하는 형태다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">리스트 방향키 이동</span>
                            </div>
                            <pre><code><span class="comment">// 리스트 아이템을 방향키로 선택</span>
<span class="keyword">const</span> list = document.querySelector(<span class="string">'.keyboard-list'</span>);
<span class="keyword">const</span> items = list.querySelectorAll(<span class="string">'.list-item'</span>);
<span class="keyword">let</span> currentIndex = <span class="number">0</span>;

<span class="keyword">function</span> <span class="function">updateSelection</span>(newIndex) {
    items[currentIndex].classList.remove(<span class="string">'selected'</span>);
    currentIndex = newIndex;
    items[currentIndex].classList.add(<span class="string">'selected'</span>);
    items[currentIndex].scrollIntoView({ block: <span class="string">'nearest'</span> });
}

list.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">switch</span> (e.key) {
        <span class="keyword">case</span> <span class="string">'ArrowDown'</span>:
            e.preventDefault();
            <span class="keyword">if</span> (currentIndex < items.length - <span class="number">1</span>) {
                updateSelection(currentIndex + <span class="number">1</span>);
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'ArrowUp'</span>:
            e.preventDefault();
            <span class="keyword">if</span> (currentIndex > <span class="number">0</span>) {
                updateSelection(currentIndex - <span class="number">1</span>);
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'Enter'</span>:
            items[currentIndex].click();
            <span class="keyword">break</span>;
    }
});</code></pre>
                        </div>

                        <!-- ✅ roving tabindex 예시 보강 -->
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">로빙 tabindex(키보드 포커스 품질 개선)</span>
                            </div>
                            <pre><code><span class="comment">// 한 항목만 tabindex=0, 나머지는 -1 (포커스 이동이 자연스러움)</span>
<span class="keyword">const</span> list = document.querySelector(<span class="string">'.keyboard-list'</span>);
<span class="keyword">const</span> items = [...list.querySelectorAll(<span class="string">'.list-item'</span>)];
<span class="keyword">let</span> idx = <span class="number">0</span>;

items.forEach((el, i) => el.tabIndex = i === idx ? <span class="number">0</span> : -<span class="number">1</span>);
items[idx].classList.add(<span class="string">'selected'</span>);

<span class="keyword">function</span> <span class="function">setActive</span>(next) {
  items[idx].classList.remove(<span class="string">'selected'</span>);
  items[idx].tabIndex = -<span class="number">1</span>;

  idx = next;
  items[idx].classList.add(<span class="string">'selected'</span>);
  items[idx].tabIndex = <span class="number">0</span>;
  items[idx].focus();
  items[idx].scrollIntoView({ block: <span class="string">'nearest'</span> });
}

list.addEventListener(<span class="string">'keydown'</span>, (e) => {
  <span class="keyword">if</span> (e.key === <span class="string">'ArrowDown'</span>) {
    e.preventDefault();
    <span class="keyword">if</span> (idx < items.length - <span class="number">1</span>) setActive(idx + <span class="number">1</span>);
  }
  <span class="keyword">if</span> (e.key === <span class="string">'ArrowUp'</span>) {
    e.preventDefault();
    <span class="keyword">if</span> (idx > <span class="number">0</span>) setActive(idx - <span class="number">1</span>);
  }
  <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) items[idx].click();
});</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">이미지 갤러리 키보드 네비게이션</span>
                            </div>
                            <pre><code><span class="comment">// 좌우 방향키로 이미지 넘기기</span>
<span class="keyword">const</span> gallery = document.querySelector(<span class="string">'.gallery'</span>);
<span class="keyword">const</span> images = gallery.querySelectorAll(<span class="string">'img'</span>);
<span class="keyword">let</span> currentImg = <span class="number">0</span>;

document.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">if</span> (!gallery.classList.contains(<span class="string">'active'</span>)) <span class="keyword">return</span>;

    <span class="keyword">if</span> (e.key === <span class="string">'ArrowRight'</span>) {
        currentImg = (currentImg + <span class="number">1</span>) % images.length;
        showImage(currentImg);
    } <span class="keyword">else</span> <span class="keyword">if</span> (e.key === <span class="string">'ArrowLeft'</span>) {
        currentImg = (currentImg - <span class="number">1</span> + images.length) % images.length;
        showImage(currentImg);
    } <span class="keyword">else</span> <span class="keyword">if</span> (e.key === <span class="string">'Escape'</span>) {
        closeGallery();
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 보강 -->
                        <div class="highlight-box info">
                            <div class="highlight-icon"><i class="fa-solid fa-door-open"></i></div>
                            <div class="highlight-content">
                                <h5>갤러리 단축키는 “활성 상태”에서만</h5>
                                <p>예제처럼 active 상태에서만 키를 소비하는 방식이 정석이다. 그렇지 않으면 페이지 어디서든 방향키가 갤러리를 움직여 버려 UX가 붕괴한다.</p>
                                <p>가능하면 갤러리 열릴 때 포커스를 갤러리 컨테이너로 옮기고, 닫을 때 원래 버튼으로 돌리는 구조까지 포함하면 더 완성도가 올라간다.</p>
                            </div>
                        </div>

                        <h5 class="sub-title">검색 및 입력</h5>
                        <p class="desc-text">입력 필드에서의 키보드 처리, 자동완성 선택 등의 기능이다.</p>

                        <!-- ✅ 설명 보강 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-magnifying-glass"></i> 입력 이벤트와 키보드 이벤트를 분리</h4>
                            <p>검색창에서 “값이 바뀌는 것”은 keydown이 아니라 <strong>input</strong> 이벤트가 더 정확하다. 키보드는 조작(선택/확정/취소)을
                                담당하고,
                                실제 검색어 변경/필터링은 input에서 처리하면 IME(한글 조합)까지 안정적으로 다룰 수 있다.</p>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">검색어 변화는 input에서 처리(IME 안정)</span>
                            </div>
                            <pre><code><span class="keyword">const</span> searchInput = document.querySelector(<span class="string">'.search-input'</span>);

searchInput.addEventListener(<span class="string">'input'</span>, () => {
  <span class="comment">// 여기에서 자동완성 목록 갱신(필터링/비동기 요청)</span>
  <span class="comment">// updateSuggestions(searchInput.value);</span>
});

searchInput.addEventListener(<span class="string">'compositionstart'</span>, () => {
  <span class="comment">// IME 조합 시작(필요 시 상태 플래그)</span>
});
searchInput.addEventListener(<span class="string">'compositionend'</span>, () => {
  <span class="comment">// IME 조합 종료 후 최종 값 확정</span>
});</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">검색창 자동완성 선택</span>
                            </div>
                            <pre><code><span class="comment">// 자동완성 목록에서 방향키로 선택, Enter로 확정</span>
<span class="keyword">const</span> searchInput = document.querySelector(<span class="string">'.search-input'</span>);
<span class="keyword">const</span> suggestions = document.querySelector(<span class="string">'.suggestions'</span>);
<span class="keyword">let</span> selectedIndex = -<span class="number">1</span>;

searchInput.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">const</span> items = suggestions.querySelectorAll(<span class="string">'.suggestion-item'</span>);
    <span class="keyword">if</span> (!items.length) <span class="keyword">return</span>;

    <span class="keyword">switch</span> (e.key) {
        <span class="keyword">case</span> <span class="string">'ArrowDown'</span>:
            e.preventDefault();
            selectedIndex = Math.min(selectedIndex + <span class="number">1</span>, items.length - <span class="number">1</span>);
            updateHighlight(items);
            <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="string">'ArrowUp'</span>:
            e.preventDefault();
            selectedIndex = Math.max(selectedIndex - <span class="number">1</span>, -<span class="number">1</span>);
            updateHighlight(items);
            <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="string">'Enter'</span>:
            <span class="keyword">if</span> (selectedIndex >= <span class="number">0</span>) {
                e.preventDefault();
                searchInput.value = items[selectedIndex].textContent;
                suggestions.classList.remove(<span class="string">'visible'</span>);
            }
            <span class="keyword">break</span>;

        <span class="keyword">case</span> <span class="string">'Escape'</span>:
            suggestions.classList.remove(<span class="string">'visible'</span>);
            <span class="keyword">break</span>;
    }
});

<span class="keyword">function</span> <span class="function">updateHighlight</span>(items) {
    items.forEach((item, i) => {
        item.classList.toggle(<span class="string">'highlighted'</span>, i === selectedIndex);
    });
}</code></pre>
                        </div>

                        <!-- ✅ 설명 보강 -->
                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-bug"></i></div>
                            <div class="highlight-content">
                                <h5>자동완성에서 자주 터지는 버그 포인트</h5>
                                <p>selectedIndex가 -1일 때(아무 것도 선택하지 않은 상태) Enter를 누르면 기본 제출이 발생할 수 있다. 그래서 Enter 처리 조건을
                                    명확히 둬야 한다.</p>
                                <p>또한 자동완성 항목을 키보드로 이동할 때는 “시각 하이라이트”만이 아니라 aria-activedescendant 같은 접근성 속성까지 붙이면 완성도가
                                    올라간다.</p>
                            </div>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">Enter로 폼 제출</span>
                            </div>
                            <pre><code><span class="comment">// 특정 입력 필드에서 Enter 누르면 폼 제출</span>
<span class="keyword">const</span> inputField = document.querySelector(<span class="string">'.submit-on-enter'</span>);

inputField.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span> && !e.shiftKey) {
        e.preventDefault();  <span class="comment">// 줄바꿈 방지</span>
        submitForm();
    }
});

<span class="comment">// Shift + Enter: 줄바꿈, Enter: 제출 (채팅 앱 패턴)</span>
<span class="keyword">const</span> chatInput = document.querySelector(<span class="string">'.chat-input'</span>);

chatInput.addEventListener(<span class="string">'keydown'</span>, (e) => {
    <span class="keyword">if</span> (e.key === <span class="string">'Enter'</span>) {
        <span class="keyword">if</span> (e.shiftKey) {
            <span class="comment">// Shift + Enter: 줄바꿈 (기본 동작)</span>
            <span class="keyword">return</span>;
        }
        e.preventDefault();
        sendMessage();
    }
});</code></pre>
                        </div>

                        <!-- ✅ 설명 보강 -->
                        <div class="content-card">
                            <h4><i class="fa-solid fa-comment"></i> 채팅 입력의 “의도 분기”</h4>
                            <p>채팅 입력은 Enter가 “전송”, Shift+Enter가 “줄바꿈”이라는 의도 규칙을 가진다. 여기서 중요한 건 키 이벤트 자체가 아니라,
                                사용자가 의도하는 텍스트 편집/전송 모드가 분리되어 있다는 점이다.</p>
                            <p>실무에서는 (1) 전송 실패 시 메시지 유지, (2) 전송 중 Enter 연타 방지, (3) IME 조합 중 Enter 처리 제외 같은 안정성까지 포함하면
                                완성도가 올라간다.</p>
                        </div>
                    </div>


                    <!-- ============================================ -->
                    <!-- 5. 터치/제스처 이벤트 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-hand-point-up"></i> 터치 및 제스처 이벤트</h4>

                        <div class="info-box">
                            <p>터치 이벤트는 모바일 기기에서 필수다. touchstart, touchmove, touchend 이벤트로 스와이프, 핀치 줌 등의 제스처를 구현할 수 있다.
                                pointer 이벤트를 사용하면 마우스와 터치를 동시에 처리할 수 있다.</p>
                        </div>

                        <h5 class="sub-title">스와이프 제스처</h5>
                        <p class="desc-text">모바일에서 좌우로 스와이프하여 슬라이드 넘기기, 메뉴 열기 등의 기능을 구현한다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-hand-pointer"></i> 스와이프 감지의 핵심 원리</h6>
                            <ul>
                                <li><strong>touchstart</strong>: 손가락이 화면에 닿는 순간 - 시작 좌표(startX, startY) 저장</li>
                                <li><strong>touchend</strong>: 손가락이 떨어지는 순간 - 끝 좌표와 비교해서 방향/거리 계산</li>
                                <li><strong>threshold</strong>: 최소 이동 거리 - 너무 작은 움직임은 스와이프로 인정 안 함 (보통 50px)</li>
                                <li><strong>diffX vs diffY</strong>: 가로 이동이 세로보다 크면 좌우 스와이프, 반대면 상하 스와이프</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">이미지 슬라이더</span>
                            <span class="use-case-tag where">카드 넘기기</span>
                            <span class="use-case-tag when">모바일 네비게이션</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 스와이프 감지</span>
                            </div>
                            <pre><code><span class="comment">// 좌우 스와이프 감지</span>
<span class="keyword">const</span> swipeArea = document.querySelector(<span class="string">'.swipe-area'</span>);
<span class="keyword">let</span> startX = <span class="number">0</span>, startY = <span class="number">0</span>;
<span class="keyword">const</span> threshold = <span class="number">50</span>;  <span class="comment">// 스와이프로 인정할 최소 거리</span>

swipeArea.addEventListener(<span class="string">'touchstart'</span>, (e) => {
    startX = e.touches[<span class="number">0</span>].clientX;
    startY = e.touches[<span class="number">0</span>].clientY;
});

swipeArea.addEventListener(<span class="string">'touchend'</span>, (e) => {
    <span class="keyword">const</span> endX = e.changedTouches[<span class="number">0</span>].clientX;
    <span class="keyword">const</span> endY = e.changedTouches[<span class="number">0</span>].clientY;
    <span class="keyword">const</span> diffX = endX - startX;
    <span class="keyword">const</span> diffY = endY - startY;

    <span class="comment">// 수평 스와이프 (세로 이동보다 가로 이동이 클 때)</span>
    <span class="keyword">if</span> (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > threshold) {
        <span class="keyword">if</span> (diffX > <span class="number">0</span>) {
            console.log(<span class="string">'오른쪽 스와이프'</span>);
            showPrevSlide();
        } <span class="keyword">else</span> {
            console.log(<span class="string">'왼쪽 스와이프'</span>);
            showNextSlide();
        }
    }
});</code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-arrows-up-down-left-right"></i> 4방향 스와이프가 필요한 경우</h6>
                            <ul>
                                <li>상하좌우 모든 방향을 감지해야 할 때 (예: 게임, 풀스크린 갤러리)</li>
                                <li><strong>maxTime</strong>: 스와이프 완료 제한 시간 - 너무 느리면 드래그로 간주</li>
                                <li><strong>callback 패턴</strong>: 방향을 인자로 받아 각 방향별 다른 동작 실행 가능</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">모바일 게임</span>
                            <span class="use-case-tag where">풀스크린 갤러리</span>
                            <span class="use-case-tag tip">재사용 가능한 함수로 만들기</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">4방향 스와이프</span>
                            </div>
                            <pre><code><span class="comment">// 상하좌우 모든 방향 스와이프 감지</span>
<span class="keyword">function</span> <span class="function">detectSwipe</span>(element, callback) {
    <span class="keyword">let</span> startX, startY, startTime;
    <span class="keyword">const</span> threshold = <span class="number">50</span>;
    <span class="keyword">const</span> maxTime = <span class="number">300</span>;  <span class="comment">// 300ms 내에 완료</span>

    element.addEventListener(<span class="string">'touchstart'</span>, (e) => {
        startX = e.touches[<span class="number">0</span>].clientX;
        startY = e.touches[<span class="number">0</span>].clientY;
        startTime = Date.now();
    });

    element.addEventListener(<span class="string">'touchend'</span>, (e) => {
        <span class="keyword">if</span> (Date.now() - startTime > maxTime) <span class="keyword">return</span>;

        <span class="keyword">const</span> endX = e.changedTouches[<span class="number">0</span>].clientX;
        <span class="keyword">const</span> endY = e.changedTouches[<span class="number">0</span>].clientY;
        <span class="keyword">const</span> diffX = endX - startX;
        <span class="keyword">const</span> diffY = endY - startY;

        <span class="keyword">let</span> direction = <span class="keyword">null</span>;

        <span class="keyword">if</span> (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > threshold) {
            direction = diffX > <span class="number">0</span> ? <span class="string">'right'</span> : <span class="string">'left'</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(diffY) > threshold) {
            direction = diffY > <span class="number">0</span> ? <span class="string">'down'</span> : <span class="string">'up'</span>;
        }

        <span class="keyword">if</span> (direction) callback(direction);
    });
}

<span class="comment">// 사용 예시</span>
detectSwipe(document.body, (dir) => {
    console.log(<span class="string">'스와이프 방향:'</span>, dir);
});</code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-trash-can"></i> 슬라이드 투 딜리트 동작 원리</h6>
                            <ul>
                                <li><strong>touchmove</strong>: 드래그 중 실시간으로 요소 이동 - 삭제 버튼이 서서히 나타남</li>
                                <li><strong>Math.min/max</strong>: 이동 범위 제한 - 왼쪽으로만, 최대 -100px까지</li>
                                <li><strong>touchend</strong>: 손 떼면 판정 - 50px 이상 밀었으면 삭제 버튼 노출 유지, 아니면 원위치</li>
                                <li>삭제 버튼은 뒤에 숨겨두고, 컨텐츠가 밀리면서 드러나는 구조</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">메일 앱</span>
                            <span class="use-case-tag where">할 일 목록</span>
                            <span class="use-case-tag where">알림 목록</span>
                            <span class="use-case-tag tip">iOS 스타일 UX</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">스와이프로 삭제 (슬라이드 투 딜리트)</span>
                            </div>
                            <pre><code><span class="comment">// 아이템을 스와이프하면 삭제 버튼 나타남</span>
<span class="keyword">const</span> listItems = document.querySelectorAll(<span class="string">'.swipe-item'</span>);

listItems.forEach(item => {
    <span class="keyword">let</span> startX = <span class="number">0</span>;
    <span class="keyword">const</span> content = item.querySelector(<span class="string">'.item-content'</span>);

    item.addEventListener(<span class="string">'touchstart'</span>, (e) => {
        startX = e.touches[<span class="number">0</span>].clientX;
    });

    item.addEventListener(<span class="string">'touchmove'</span>, (e) => {
        <span class="keyword">const</span> currentX = e.touches[<span class="number">0</span>].clientX;
        <span class="keyword">let</span> diff = currentX - startX;

        <span class="comment">// 왼쪽으로만 스와이프 허용 (최대 -100px)</span>
        diff = Math.min(<span class="number">0</span>, Math.max(-<span class="number">100</span>, diff));
        content.style.transform = <span class="string">`translateX(</span><span class="interpolation">${diff}</span><span class="string">px)`</span>;
    });

    item.addEventListener(<span class="string">'touchend'</span>, (e) => {
        <span class="keyword">const</span> endX = e.changedTouches[<span class="number">0</span>].clientX;
        <span class="keyword">const</span> diff = endX - startX;

        <span class="comment">// 50px 이상 스와이프하면 삭제 버튼 노출 유지</span>
        <span class="keyword">if</span> (diff < -<span class="number">50</span>) {
            content.style.transform = <span class="string">'translateX(-100px)'</span>;
        } <span class="keyword">else</span> {
            content.style.transform = <span class="string">'translateX(0)'</span>;
        }
    });
});</code></pre>
                        </div>

                        <h5 class="sub-title">터치 슬라이더</h5>
                        <p class="desc-text">터치로 드래그하여 슬라이드를 넘기는 기능이다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-images"></i> 터치 슬라이더 동작 원리</h6>
                            <ul>
                                <li><strong>touchstart</strong>: 시작 위치 저장 + transition 끄기 (드래그 중에는 애니메이션 없이 즉시 반응)</li>
                                <li><strong>touchmove</strong>: 현재 위치 - 시작 위치 = 이동량 → transform으로 실시간 이동</li>
                                <li><strong>touchend</strong>: 이동량이 100px 이상이면 슬라이드 변경, 아니면 원위치</li>
                                <li><strong>currentIndex</strong>: 현재 슬라이드 번호 - 이 값으로 최종 위치 계산</li>
                                <li><strong>prevTranslate</strong>: 이전 위치 저장 - 다음 드래그 시 시작점으로 사용</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">제품 이미지 슬라이더</span>
                            <span class="use-case-tag where">온보딩 화면</span>
                            <span class="use-case-tag where">카드 스와이프</span>
                            <span class="use-case-tag tip">Swiper.js 대안</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">터치 드래그 슬라이더</span>
                            </div>
                            <pre><code><span class="comment">// 터치로 드래그하며 슬라이드 이동</span>
<span class="keyword">const</span> slider = document.querySelector(<span class="string">'.touch-slider'</span>);
<span class="keyword">const</span> track = slider.querySelector(<span class="string">'.slider-track'</span>);
<span class="keyword">let</span> startPos = <span class="number">0</span>, currentTranslate = <span class="number">0</span>, prevTranslate = <span class="number">0</span>;
<span class="keyword">let</span> isDragging = <span class="boolean">false</span>;
<span class="keyword">let</span> currentIndex = <span class="number">0</span>;

slider.addEventListener(<span class="string">'touchstart'</span>, (e) => {
    startPos = e.touches[<span class="number">0</span>].clientX;
    isDragging = <span class="boolean">true</span>;
    track.style.transition = <span class="string">'none'</span>;
});

slider.addEventListener(<span class="string">'touchmove'</span>, (e) => {
    <span class="keyword">if</span> (!isDragging) <span class="keyword">return</span>;
    <span class="keyword">const</span> currentPos = e.touches[<span class="number">0</span>].clientX;
    currentTranslate = prevTranslate + currentPos - startPos;
    track.style.transform = <span class="string">`translateX(</span><span class="interpolation">${currentTranslate}</span><span class="string">px)`</span>;
});

slider.addEventListener(<span class="string">'touchend'</span>, () => {
    isDragging = <span class="boolean">false</span>;
    track.style.transition = <span class="string">'transform 0.3s ease'</span>;

    <span class="keyword">const</span> movedBy = currentTranslate - prevTranslate;
    <span class="keyword">const</span> slideWidth = slider.offsetWidth;

    <span class="comment">// 슬라이드 변경 판정</span>
    <span class="keyword">if</span> (movedBy < -<span class="number">100</span>) currentIndex++;
    <span class="keyword">if</span> (movedBy > <span class="number">100</span>) currentIndex--;

    <span class="comment">// 범위 제한</span>
    currentIndex = Math.max(<span class="number">0</span>, Math.min(currentIndex, slides.length - <span class="number">1</span>));

    currentTranslate = -currentIndex * slideWidth;
    prevTranslate = currentTranslate;
    track.style.transform = <span class="string">`translateX(</span><span class="interpolation">${currentTranslate}</span><span class="string">px)`</span>;
});</code></pre>
                        </div>

                        <h5 class="sub-title">핀치 줌</h5>
                        <p class="desc-text">두 손가락으로 확대/축소하는 제스처다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-magnifying-glass-plus"></i> 핀치 줌 동작 원리</h6>
                            <ul>
                                <li><strong>e.touches.length === 2</strong>: 두 손가락이 닿았을 때만 동작</li>
                                <li><strong>getDistance()</strong>: 두 터치 포인트 사이의 거리 계산 (피타고라스 정리)</li>
                                <li><strong>initialDistance</strong>: 처음 두 손가락 사이 거리 저장</li>
                                <li><strong>currentDistance / initialDistance</strong>: 비율로 확대/축소량 계산</li>
                                <li><strong>Math.min/max</strong>: 확대 범위 제한 (0.5배 ~ 3배)</li>
                                <li><strong>e.preventDefault()</strong>: 브라우저 기본 핀치 줌 방지 (필수)</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">이미지 뷰어</span>
                            <span class="use-case-tag where">지도</span>
                            <span class="use-case-tag where">상품 상세 이미지</span>
                            <span class="use-case-tag tip">모바일 전용</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">핀치 줌 (확대/축소)</span>
                            </div>
                            <pre><code><span class="comment">// 두 손가락 핀치로 이미지 확대/축소</span>
<span class="keyword">const</span> zoomImage = document.querySelector(<span class="string">'.pinch-zoom'</span>);
<span class="keyword">let</span> scale = <span class="number">1</span>, initialDistance = <span class="number">0</span>;

zoomImage.addEventListener(<span class="string">'touchstart'</span>, (e) => {
    <span class="keyword">if</span> (e.touches.length === <span class="number">2</span>) {
        initialDistance = getDistance(e.touches[<span class="number">0</span>], e.touches[<span class="number">1</span>]);
    }
});

zoomImage.addEventListener(<span class="string">'touchmove'</span>, (e) => {
    <span class="keyword">if</span> (e.touches.length === <span class="number">2</span>) {
        e.preventDefault();
        <span class="keyword">const</span> currentDistance = getDistance(e.touches[<span class="number">0</span>], e.touches[<span class="number">1</span>]);
        <span class="keyword">const</span> scaleChange = currentDistance / initialDistance;

        scale = Math.min(Math.max(scale * scaleChange, <span class="number">0.5</span>), <span class="number">3</span>);  <span class="comment">// 0.5x ~ 3x</span>
        zoomImage.style.transform = <span class="string">`scale(</span><span class="interpolation">${scale}</span><span class="string">)`</span>;

        initialDistance = currentDistance;
    }
});

<span class="comment">// 두 터치 포인트 사이 거리 계산</span>
<span class="keyword">function</span> <span class="function">getDistance</span>(touch1, touch2) {
    <span class="keyword">const</span> dx = touch1.clientX - touch2.clientX;
    <span class="keyword">const</span> dy = touch1.clientY - touch2.clientY;
    <span class="keyword">return</span> Math.sqrt(dx * dx + dy * dy);
}</code></pre>
                        </div>

                        <div class="highlight-box warning">
                            <div class="highlight-icon"><i class="fa-solid fa-triangle-exclamation"></i></div>
                            <div class="highlight-content">
                                <h5>핀치 줌 구현 시 주의사항</h5>
                                <p><strong>HTML/CSS 필수 설정:</strong> 이미지를 감싸는 컨테이너에 <code>overflow: hidden</code>과 <code>touch-action: none</code>을 설정해야 브라우저 기본 동작과 충돌하지 않는다.</p>
                                <p><strong>확대 중심점:</strong> 현재 코드는 이미지 중심으로 확대된다. 손가락 사이 중심점으로 확대하려면 <code>transform-origin</code>도 함께 계산해야 한다.</p>
                            </div>
                        </div>

                        <div class="content-card">
                            <h4><i class="fa-solid fa-code"></i> 필요한 HTML/CSS 구조</h4>
                            <p><strong>HTML:</strong> <code>&lt;div class="pinch-container"&gt;&lt;img class="pinch-zoom" src="image.jpg"&gt;&lt;/div&gt;</code></p>
                            <p><strong>CSS:</strong> <code>.pinch-container { overflow: hidden; touch-action: none; } .pinch-zoom { transition: transform 0.1s; }</code></p>
                        </div>
                    </div>

                    <!-- ============================================ -->
                    <!-- 6. 폼 처리 및 유효성 검사 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-clipboard-check"></i> 폼 처리 및 유효성 검사</h4>

                        <div class="info-box">
                            <p>폼 처리는 웹 개발의 핵심이다. 실시간 유효성 검사로 사용자 경험을 향상시키고, 제출 전 데이터를 검증해야 한다. HTML5 기본 유효성 검사와
                                JavaScript 커스텀 검사를 조합하면 효과적이다.</p>
                        </div>

                        <h5 class="sub-title">실시간 유효성 검사</h5>
                        <p class="desc-text">입력과 동시에 유효성을 검사하여 즉각적인 피드백을 제공한다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-envelope"></i> 이메일 검증 동작 원리</h6>
                            <ul>
                                <li><strong>input 이벤트</strong>: 한 글자 입력할 때마다 실행 (keyup보다 정확)</li>
                                <li><strong>정규표현식</strong>: <code>/^[^\s@]+@[^\s@]+\.[^\s@]+$/</code> - 기본적인 이메일 형식 체크</li>
                                <li><strong>클래스 토글</strong>: valid/invalid 클래스로 CSS 스타일 변경 (초록색 테두리, 빨간색 테두리)</li>
                                <li><strong>빈 값 처리</strong>: 입력 전에는 아무 표시도 하지 않음 (UX 향상)</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">회원가입 폼</span>
                            <span class="use-case-tag where">로그인 폼</span>
                            <span class="use-case-tag tip">서버 검증도 필수</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">이메일 실시간 검증</span>
                            </div>
                            <pre><code><span class="comment">// 입력할 때마다 이메일 형식 검사</span>
<span class="keyword">const</span> emailInput = document.querySelector(<span class="string">'#email'</span>);
<span class="keyword">const</span> emailError = document.querySelector(<span class="string">'.email-error'</span>);

emailInput.addEventListener(<span class="string">'input'</span>, () => {
    <span class="keyword">const</span> email = emailInput.value;
    <span class="keyword">const</span> isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

    <span class="keyword">if</span> (email === <span class="string">''</span>) {
        emailInput.classList.remove(<span class="string">'valid'</span>, <span class="string">'invalid'</span>);
        emailError.textContent = <span class="string">''</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (isValid) {
        emailInput.classList.remove(<span class="string">'invalid'</span>);
        emailInput.classList.add(<span class="string">'valid'</span>);
        emailError.textContent = <span class="string">''</span>;
    } <span class="keyword">else</span> {
        emailInput.classList.remove(<span class="string">'valid'</span>);
        emailInput.classList.add(<span class="string">'invalid'</span>);
        emailError.textContent = <span class="string">'올바른 이메일 형식이 아닙니다'</span>;
    }
});</code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-key"></i> 비밀번호 강도 체크 원리</h6>
                            <ul>
                                <li><strong>강도 점수</strong>: 조건 충족 시마다 +1점 (최대 4점 → 3으로 제한)</li>
                                <li><strong>체크 조건</strong>: 8자 이상, 대소문자 혼용, 숫자 포함, 특수문자 포함</li>
                                <li><strong>시각적 피드백</strong>: 막대 너비(25%~100%)와 색상(빨강→초록)으로 표시</li>
                                <li><strong>레벨 배열</strong>: ['weak', 'fair', 'good', 'strong'] - CSS 클래스와 매핑</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">회원가입</span>
                            <span class="use-case-tag where">비밀번호 변경</span>
                            <span class="use-case-tag tip">진행 바로 시각화</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">비밀번호 강도 체크</span>
                            </div>
                            <pre><code><span class="comment">// 비밀번호 강도를 실시간으로 표시</span>
<span class="keyword">const</span> passwordInput = document.querySelector(<span class="string">'#password'</span>);
<span class="keyword">const</span> strengthBar = document.querySelector(<span class="string">'.strength-bar'</span>);
<span class="keyword">const</span> strengthText = document.querySelector(<span class="string">'.strength-text'</span>);

passwordInput.addEventListener(<span class="string">'input'</span>, () => {
    <span class="keyword">const</span> password = passwordInput.value;
    <span class="keyword">const</span> strength = checkPasswordStrength(password);

    <span class="keyword">const</span> levels = [<span class="string">'weak'</span>, <span class="string">'fair'</span>, <span class="string">'good'</span>, <span class="string">'strong'</span>];
    <span class="keyword">const</span> labels = [<span class="string">'약함'</span>, <span class="string">'보통'</span>, <span class="string">'좋음'</span>, <span class="string">'강함'</span>];

    strengthBar.className = <span class="string">'strength-bar '</span> + levels[strength];
    strengthBar.style.width = ((strength + <span class="number">1</span>) * <span class="number">25</span>) + <span class="string">'%'</span>;
    strengthText.textContent = labels[strength];
});

<span class="keyword">function</span> <span class="function">checkPasswordStrength</span>(password) {
    <span class="keyword">let</span> strength = <span class="number">0</span>;

    <span class="keyword">if</span> (password.length >= <span class="number">8</span>) strength++;
    <span class="keyword">if</span> (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
    <span class="keyword">if</span> (/\d/.test(password)) strength++;
    <span class="keyword">if</span> (/[^a-zA-Z0-9]/.test(password)) strength++;

    <span class="keyword">return</span> Math.min(strength, <span class="number">3</span>);
}</code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-check-double"></i> 비밀번호 확인 동작 원리</h6>
                            <ul>
                                <li><strong>양쪽 모두 감시</strong>: password와 confirmPassword 둘 다 input 이벤트 등록</li>
                                <li><strong>값 비교</strong>: 단순 문자열 비교 (===)</li>
                                <li><strong>상태 3가지</strong>: 빈 값(표시 없음), 일치(초록), 불일치(빨강)</li>
                                <li><strong>왜 양쪽 감시?</strong>: 비밀번호를 나중에 수정하면 확인 필드도 다시 체크해야 함</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">회원가입</span>
                            <span class="use-case-tag where">비밀번호 변경</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">비밀번호 확인 일치</span>
                            </div>
                            <pre><code><span class="comment">// 비밀번호 확인 필드 일치 검사</span>
<span class="keyword">const</span> password = document.querySelector(<span class="string">'#password'</span>);
<span class="keyword">const</span> confirmPassword = document.querySelector(<span class="string">'#confirm-password'</span>);
<span class="keyword">const</span> matchMessage = document.querySelector(<span class="string">'.match-message'</span>);

<span class="keyword">function</span> <span class="function">checkMatch</span>() {
    <span class="keyword">if</span> (confirmPassword.value === <span class="string">''</span>) {
        matchMessage.textContent = <span class="string">''</span>;
        confirmPassword.classList.remove(<span class="string">'valid'</span>, <span class="string">'invalid'</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (password.value === confirmPassword.value) {
        matchMessage.textContent = <span class="string">'비밀번호가 일치합니다'</span>;
        matchMessage.className = <span class="string">'match-message success'</span>;
        confirmPassword.classList.add(<span class="string">'valid'</span>);
        confirmPassword.classList.remove(<span class="string">'invalid'</span>);
    } <span class="keyword">else</span> {
        matchMessage.textContent = <span class="string">'비밀번호가 일치하지 않습니다'</span>;
        matchMessage.className = <span class="string">'match-message error'</span>;
        confirmPassword.classList.add(<span class="string">'invalid'</span>);
        confirmPassword.classList.remove(<span class="string">'valid'</span>);
    }
}

password.addEventListener(<span class="string">'input'</span>, checkMatch);
confirmPassword.addEventListener(<span class="string">'input'</span>, checkMatch);</code></pre>
                        </div>

                        <h5 class="sub-title">폼 제출 처리</h5>
                        <p class="desc-text">폼 제출 시 유효성 검사와 서버 전송 처리다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-paper-plane"></i> 폼 제출 처리 흐름</h6>
                            <ul>
                                <li><strong>e.preventDefault()</strong>: 폼 기본 제출(페이지 새로고침) 막기</li>
                                <li><strong>validateForm()</strong>: 모든 필드 검사 → 에러 배열 반환</li>
                                <li><strong>에러 있으면</strong>: showErrors()로 각 필드에 에러 메시지 표시 + 첫 에러 필드에 포커스</li>
                                <li><strong>에러 없으면</strong>: submitForm()으로 서버 전송</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">회원가입</span>
                            <span class="use-case-tag where">문의 폼</span>
                            <span class="use-case-tag where">주문서</span>
                            <span class="use-case-tag tip">실시간 검증과 병행</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">폼 유효성 검사 후 제출</span>
                            </div>
                            <pre><code><span class="comment">// 폼 전체 유효성 검사 후 제출</span>
<span class="keyword">const</span> form = document.querySelector(<span class="string">'#signup-form'</span>);

form.addEventListener(<span class="string">'submit'</span>, (e) => {
    e.preventDefault();

    <span class="keyword">const</span> errors = validateForm();

    <span class="keyword">if</span> (errors.length > <span class="number">0</span>) {
        showErrors(errors);
        <span class="keyword">return</span>;
    }

    <span class="comment">// 유효성 검사 통과 - 제출</span>
    submitForm();
});

<span class="keyword">function</span> <span class="function">validateForm</span>() {
    <span class="keyword">const</span> errors = [];
    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(form);

    <span class="keyword">if</span> (!formData.get(<span class="string">'name'</span>).trim()) {
        errors.push({ field: <span class="string">'name'</span>, message: <span class="string">'이름을 입력하세요'</span> });
    }

    <span class="keyword">if</span> (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.get(<span class="string">'email'</span>))) {
        errors.push({ field: <span class="string">'email'</span>, message: <span class="string">'올바른 이메일을 입력하세요'</span> });
    }

    <span class="keyword">if</span> (formData.get(<span class="string">'password'</span>).length < <span class="number">8</span>) {
        errors.push({ field: <span class="string">'password'</span>, message: <span class="string">'비밀번호는 8자 이상이어야 합니다'</span> });
    }

    <span class="keyword">return</span> errors;
}

<span class="keyword">function</span> <span class="function">showErrors</span>(errors) {
    <span class="comment">// 기존 에러 메시지 제거</span>
    form.querySelectorAll(<span class="string">'.error-message'</span>).forEach(el => el.remove());
    form.querySelectorAll(<span class="string">'.invalid'</span>).forEach(el => el.classList.remove(<span class="string">'invalid'</span>));

    errors.forEach(error => {
        <span class="keyword">const</span> field = form.querySelector(<span class="string">`[name="</span><span class="interpolation">${error.field}</span><span class="string">"]`</span>);
        field.classList.add(<span class="string">'invalid'</span>);

        <span class="keyword">const</span> errorEl = document.createElement(<span class="string">'span'</span>);
        errorEl.className = <span class="string">'error-message'</span>;
        errorEl.textContent = error.message;
        field.parentNode.appendChild(errorEl);
    });

    <span class="comment">// 첫 번째 에러 필드에 포커스</span>
    form.querySelector(<span class="string">'.invalid'</span>)?.focus();
}</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">Fetch로 폼 데이터 전송</span>
                            </div>
                            <pre><code><span class="comment">// FormData를 사용한 비동기 폼 제출</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">submitForm</span>() {
    <span class="keyword">const</span> submitBtn = form.querySelector(<span class="string">'button[type="submit"]'</span>);
    <span class="keyword">const</span> originalText = submitBtn.textContent;

    <span class="keyword">try</span> {
        <span class="comment">// 로딩 상태</span>
        submitBtn.disabled = <span class="boolean">true</span>;
        submitBtn.textContent = <span class="string">'처리 중...'</span>;

        <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(form);

        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/api/signup'</span>, {
            method: <span class="string">'POST'</span>,
            body: formData
        });

        <span class="keyword">if</span> (!response.ok) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'서버 오류가 발생했습니다'</span>);
        }

        <span class="keyword">const</span> result = <span class="keyword">await</span> response.json();
        showSuccess(<span class="string">'회원가입이 완료되었습니다!'</span>);

    } <span class="keyword">catch</span> (error) {
        showError(error.message);
    } <span class="keyword">finally</span> {
        submitBtn.disabled = <span class="boolean">false</span>;
        submitBtn.textContent = originalText;
    }
}</code></pre>
                        </div>

                        <h5 class="sub-title">입력 포맷팅</h5>
                        <p class="desc-text">전화번호, 카드번호 등 특정 형식으로 자동 포맷팅한다.</p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">전화번호 자동 포맷팅</span>
                            </div>
                            <pre><code><span class="comment">// 010-1234-5678 형식으로 자동 변환</span>
<span class="keyword">const</span> phoneInput = document.querySelector(<span class="string">'#phone'</span>);

phoneInput.addEventListener(<span class="string">'input'</span>, (e) => {
    <span class="keyword">let</span> value = e.target.value.replace(/\D/g, <span class="string">''</span>);  <span class="comment">// 숫자만</span>

    <span class="keyword">if</span> (value.length > <span class="number">11</span>) {
        value = value.slice(<span class="number">0</span>, <span class="number">11</span>);
    }

    <span class="keyword">if</span> (value.length > <span class="number">7</span>) {
        value = value.replace(/(\d{3})(\d{4})(\d+)/, <span class="string">'$1-$2-$3'</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (value.length > <span class="number">3</span>) {
        value = value.replace(/(\d{3})(\d+)/, <span class="string">'$1-$2'</span>);
    }

    e.target.value = value;
});</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">신용카드 번호 포맷팅</span>
                            </div>
                            <pre><code><span class="comment">// 1234 5678 9012 3456 형식</span>
<span class="keyword">const</span> cardInput = document.querySelector(<span class="string">'#card-number'</span>);

cardInput.addEventListener(<span class="string">'input'</span>, (e) => {
    <span class="keyword">let</span> value = e.target.value.replace(/\D/g, <span class="string">''</span>);

    <span class="keyword">if</span> (value.length > <span class="number">16</span>) {
        value = value.slice(<span class="number">0</span>, <span class="number">16</span>);
    }

    <span class="comment">// 4자리마다 공백 추가</span>
    value = value.replace(/(\d{4})(?=\d)/g, <span class="string">'$1 '</span>);

    e.target.value = value;
});

<span class="comment">// 카드 종류 감지</span>
<span class="keyword">function</span> <span class="function">detectCardType</span>(number) {
    <span class="keyword">const</span> patterns = {
        visa: /^4/,
        mastercard: /^5[1-5]/,
        amex: /^3[47]/,
    };

    <span class="keyword">for</span> (<span class="keyword">const</span> [type, pattern] <span class="keyword">of</span> Object.entries(patterns)) {
        <span class="keyword">if</span> (pattern.test(number)) <span class="keyword">return</span> type;
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}</code></pre>
                        </div>
                    </div>

                    <!-- ============================================ -->
                    <!-- 7. 알림 및 토스트 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-bell"></i> 알림 및 토스트</h4>

                        <div class="info-box">
                            <p>사용자에게 피드백을 제공하는 알림 시스템이다. 토스트 메시지는 잠시 나타났다 사라지고, 알림은 사용자가 확인할 때까지 유지될 수 있다. 액션 완료, 에러 발생
                                등 다양한 상황에서 사용한다.</p>
                        </div>

                        <h5 class="sub-title">토스트 메시지</h5>
                        <p class="desc-text">화면 구석에 잠시 나타났다 사라지는 알림이다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-comment-dots"></i> 토스트 시스템 동작 원리</h6>
                            <ul>
                                <li><strong>동적 생성</strong>: 토스트가 필요할 때마다 DOM 요소 생성 → 컨테이너에 추가</li>
                                <li><strong>requestAnimationFrame</strong>: 요소 추가 후 다음 프레임에서 active 클래스 추가 (애니메이션 트리거)</li>
                                <li><strong>자동 제거</strong>: setTimeout으로 duration(기본 3초) 후 제거</li>
                                <li><strong>transitionend</strong>: 사라지는 애니메이션 끝나면 DOM에서 완전히 제거</li>
                                <li><strong>type 파라미터</strong>: 'success', 'error', 'warning', 'info'로 색상 구분</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">저장 완료 알림</span>
                            <span class="use-case-tag where">에러 알림</span>
                            <span class="use-case-tag where">복사 완료</span>
                            <span class="use-case-tag tip">모달보다 덜 침습적</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">기본 토스트 시스템</span>
                            </div>
                            <pre><code><span class="comment">// 토스트 메시지 표시 시스템</span>
<span class="keyword">function</span> <span class="function">showToast</span>(message, type = <span class="string">'info'</span>, duration = <span class="number">3000</span>) {
    <span class="keyword">const</span> container = document.querySelector(<span class="string">'.toast-container'</span>)
        || createToastContainer();

    <span class="keyword">const</span> toast = document.createElement(<span class="string">'div'</span>);
    toast.className = <span class="string">`toast toast-</span><span class="interpolation">${type}</span><span class="string">`</span>;
    toast.innerHTML = <span class="string">`
        &lt;span class="toast-message"&gt;</span><span class="interpolation">${message}</span><span class="string">&lt;/span&gt;
        &lt;button class="toast-close"&gt;&amp;times;&lt;/button&gt;
    `</span>;

    container.appendChild(toast);

    <span class="comment">// 애니메이션을 위해 다음 프레임에서 active 추가</span>
    requestAnimationFrame(() => toast.classList.add(<span class="string">'active'</span>));

    <span class="comment">// 닫기 버튼</span>
    toast.querySelector(<span class="string">'.toast-close'</span>).onclick = () => removeToast(toast);

    <span class="comment">// 자동 제거</span>
    <span class="keyword">if</span> (duration > <span class="number">0</span>) {
        setTimeout(() => removeToast(toast), duration);
    }

    <span class="keyword">return</span> toast;
}

<span class="keyword">function</span> <span class="function">removeToast</span>(toast) {
    toast.classList.remove(<span class="string">'active'</span>);
    toast.addEventListener(<span class="string">'transitionend'</span>, () => toast.remove());
}

<span class="keyword">function</span> <span class="function">createToastContainer</span>() {
    <span class="keyword">const</span> container = document.createElement(<span class="string">'div'</span>);
    container.className = <span class="string">'toast-container'</span>;
    document.body.appendChild(container);
    <span class="keyword">return</span> container;
}

<span class="comment">// 사용 예시</span>
showToast(<span class="string">'저장되었습니다'</span>, <span class="string">'success'</span>);
showToast(<span class="string">'오류가 발생했습니다'</span>, <span class="string">'error'</span>);
showToast(<span class="string">'주의가 필요합니다'</span>, <span class="string">'warning'</span>);</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">CSS</span>
                                <span class="code-title">토스트 스타일</span>
                            </div>
                            <pre><code><span class="comment">/* 토스트 컨테이너 */</span>
.toast-container {
    position: fixed;
    bottom: <span class="number">20</span>px;
    right: <span class="number">20</span>px;
    z-index: <span class="number">9999</span>;
    display: flex;
    flex-direction: column;
    gap: <span class="number">10</span>px;
}

<span class="comment">/* 토스트 기본 스타일 */</span>
.toast {
    padding: <span class="number">12</span>px <span class="number">20</span>px;
    border-radius: <span class="number">8</span>px;
    display: flex;
    align-items: center;
    gap: <span class="number">10</span>px;
    opacity: <span class="number">0</span>;
    transform: translateX(<span class="number">100</span>%);
    transition: all <span class="number">0.3</span>s ease;
}

.toast.active {
    opacity: <span class="number">1</span>;
    transform: translateX(<span class="number">0</span>);
}

<span class="comment">/* 타입별 색상 */</span>
.toast-success { background: <span class="string">#4caf50</span>; color: white; }
.toast-error { background: <span class="string">#f44336</span>; color: white; }
.toast-warning { background: <span class="string">#ff9800</span>; color: white; }
.toast-info { background: <span class="string">#2196f3</span>; color: white; }</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">액션 버튼이 있는 토스트</span>
                            </div>
                            <pre><code><span class="comment">// '되돌리기' 등 액션 버튼이 있는 토스트</span>
<span class="keyword">function</span> <span class="function">showUndoToast</span>(message, undoCallback) {
    <span class="keyword">const</span> container = document.querySelector(<span class="string">'.toast-container'</span>);

    <span class="keyword">const</span> toast = document.createElement(<span class="string">'div'</span>);
    toast.className = <span class="string">'toast toast-action'</span>;
    toast.innerHTML = <span class="string">`
        &lt;span class="toast-message"&gt;</span><span class="interpolation">${message}</span><span class="string">&lt;/span&gt;
        &lt;button class="toast-undo"&gt;되돌리기&lt;/button&gt;
    `</span>;

    container.appendChild(toast);
    requestAnimationFrame(() => toast.classList.add(<span class="string">'active'</span>));

    <span class="keyword">let</span> timeoutId = setTimeout(() => removeToast(toast), <span class="number">5000</span>);

    toast.querySelector(<span class="string">'.toast-undo'</span>).onclick = () => {
        clearTimeout(timeoutId);
        undoCallback();
        removeToast(toast);
        showToast(<span class="string">'되돌렸습니다'</span>, <span class="string">'success'</span>);
    };
}

<span class="comment">// 사용 예시</span>
showUndoToast(<span class="string">'항목이 삭제되었습니다'</span>, () => {
    <span class="comment">// 삭제 취소 로직</span>
    restoreItem(deletedItem);
});</code></pre>
                        </div>

                        <h5 class="sub-title">알림 배너</h5>
                        <p class="desc-text">페이지 상단에 나타나는 알림 배너다.</p>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">알림 배너</span>
                            </div>
                            <pre><code><span class="comment">// 페이지 상단 알림 배너</span>
<span class="keyword">function</span> <span class="function">showBanner</span>(message, type = <span class="string">'info'</span>, dismissible = <span class="boolean">true</span>) {
    <span class="comment">// 기존 배너 제거</span>
    document.querySelector(<span class="string">'.alert-banner'</span>)?.remove();

    <span class="keyword">const</span> banner = document.createElement(<span class="string">'div'</span>);
    banner.className = <span class="string">`alert-banner banner-</span><span class="interpolation">${type}</span><span class="string">`</span>;
    banner.innerHTML = <span class="string">`
        &lt;span&gt;</span><span class="interpolation">${message}</span><span class="string">&lt;/span&gt;
        </span><span class="interpolation">${dismissible ? <span class="string">'&lt;button class="banner-close"&gt;&amp;times;&lt;/button&gt;'</span> : <span class="string">''</span>}</span><span class="string">
    `</span>;

    document.body.prepend(banner);

    <span class="keyword">if</span> (dismissible) {
        banner.querySelector(<span class="string">'.banner-close'</span>).onclick = () => {
            banner.classList.add(<span class="string">'hiding'</span>);
            banner.addEventListener(<span class="string">'animationend'</span>, () => banner.remove());
        };
    }
}

<span class="comment">/* CSS */</span>
<span class="comment">// .alert-banner { padding: 12px 20px; text-align: center; }</span>
<span class="comment">// .banner-info { background: #e3f2fd; }</span>
<span class="comment">// .banner-warning { background: #fff3e0; }</span>
<span class="comment">// .banner-error { background: #ffebee; }</span></code></pre>
                        </div>
                    </div>

                    <!-- ============================================ -->
                    <!-- 8. 로컬 스토리지 활용 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-database"></i> 로컬 스토리지 활용</h4>

                        <div class="info-box">
                            <p>localStorage와 sessionStorage를 활용해 브라우저에 데이터를 저장한다. 새로고침해도 유지되는 사용자 설정, 폼 임시 저장, 장바구니 등에
                                활용된다. 문자열만 저장할 수 있어 객체는 JSON으로 변환해야 한다.</p>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-hard-drive"></i> 로컬 스토리지 기본 개념</h6>
                            <ul>
                                <li><strong>localStorage</strong>: 브라우저 닫아도 유지 (영구 저장)</li>
                                <li><strong>sessionStorage</strong>: 탭 닫으면 삭제 (세션 동안만)</li>
                                <li><strong>용량</strong>: 도메인당 약 5MB</li>
                                <li><strong>문자열만 저장</strong>: 객체는 JSON.stringify() 필수</li>
                                <li><strong>동기 API</strong>: 큰 데이터 저장 시 메인 스레드 블로킹 주의</li>
                            </ul>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">사용자 설정 저장</span>
                            <span class="use-case-tag where">장바구니</span>
                            <span class="use-case-tag where">최근 본 상품</span>
                            <span class="use-case-tag tip">민감 정보 저장 금지</span>
                        </div>
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">로컬 스토리지 헬퍼 함수</span>
                            </div>
                            <pre><code><span class="comment">// 로컬 스토리지 편의 함수</span>
<span class="keyword">const</span> storage = {
    <span class="comment">// 데이터 저장 (객체 자동 변환)</span>
    set(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    },

    <span class="comment">// 데이터 불러오기</span>
    get(key, defaultValue = <span class="keyword">null</span>) {
        <span class="keyword">const</span> item = localStorage.getItem(key);
        <span class="keyword">try</span> {
            <span class="keyword">return</span> item ? JSON.parse(item) : defaultValue;
        } <span class="keyword">catch</span> {
            <span class="keyword">return</span> item || defaultValue;
        }
    },

    <span class="comment">// 삭제</span>
    remove(key) {
        localStorage.removeItem(key);
    },

    <span class="comment">// 전체 삭제</span>
    clear() {
        localStorage.clear();
    }
};

<span class="comment">// 사용 예시</span>
storage.set(<span class="string">'user'</span>, { name: <span class="string">'홍길동'</span>, age: <span class="number">25</span> });
<span class="keyword">const</span> user = storage.get(<span class="string">'user'</span>);  <span class="comment">// { name: '홍길동', age: 25 }</span></code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">폼 임시 저장</span>
                            </div>
                            <pre><code><span class="comment">// 작성 중인 폼 자동 저장 (브라우저 닫아도 유지)</span>
<span class="keyword">const</span> form = document.querySelector(<span class="string">'#article-form'</span>);
<span class="keyword">const</span> STORAGE_KEY = <span class="string">'draft_article'</span>;

<span class="comment">// 저장된 내용 불러오기</span>
<span class="keyword">const</span> savedData = storage.get(STORAGE_KEY);
<span class="keyword">if</span> (savedData) {
    Object.entries(savedData).forEach(([name, value]) => {
        <span class="keyword">const</span> field = form.querySelector(<span class="string">`[name="</span><span class="interpolation">${name}</span><span class="string">"]`</span>);
        <span class="keyword">if</span> (field) field.value = value;
    });
}

<span class="comment">// 입력 시 자동 저장 (디바운스 적용)</span>
<span class="keyword">const</span> autoSave = debounce(() => {
    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData(form);
    <span class="keyword">const</span> data = Object.fromEntries(formData);
    storage.set(STORAGE_KEY, data);
    console.log(<span class="string">'자동 저장됨'</span>);
}, <span class="number">1000</span>);

form.addEventListener(<span class="string">'input'</span>, autoSave);

<span class="comment">// 제출 시 임시 저장 삭제</span>
form.addEventListener(<span class="string">'submit'</span>, () => {
    storage.remove(STORAGE_KEY);
});</code></pre>
                        </div>

                        <h5 class="sub-title">실전 활용: 장바구니</h5>
                        <div class="code-explain">
                            <h6><i class="fa-solid fa-cart-shopping"></i> 장바구니 구현 핵심 포인트</h6>
                            <ul>
                                <li><strong>객체 패턴</strong>: 관련 메서드를 하나의 객체로 그룹화하여 관리 용이</li>
                                <li><strong>중복 처리</strong>: 같은 상품 추가 시 수량만 증가 (find로 기존 상품 확인)</li>
                                <li><strong>UI 동기화</strong>: 데이터 변경 시마다 updateUI() 호출로 화면 반영</li>
                                <li><strong>총액 계산</strong>: reduce로 가격 x 수량 합계 계산</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">이커머스 사이트</span>
                            <span class="use-case-tag when">로그인 없이 장바구니 유지</span>
                            <span class="use-case-tag tip">서버 연동 전 프로토타입에 적합</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">장바구니 구현</span>
                            </div>
                            <pre><code><span class="comment">// 장바구니 관리 (로컬 스토리지 활용)</span>
<span class="keyword">const</span> cart = {
    STORAGE_KEY: <span class="string">'shopping_cart'</span>,

    <span class="comment">// 장바구니 가져오기</span>
    getItems() {
        <span class="keyword">return</span> storage.get(<span class="keyword">this</span>.STORAGE_KEY, []);
    },

    <span class="comment">// 상품 추가</span>
    addItem(product) {
        <span class="keyword">const</span> items = <span class="keyword">this</span>.getItems();
        <span class="keyword">const</span> existing = items.find(item => item.id === product.id);

        <span class="keyword">if</span> (existing) {
            existing.quantity += product.quantity || <span class="number">1</span>;
        } <span class="keyword">else</span> {
            items.push({ ...product, quantity: product.quantity || <span class="number">1</span> });
        }

        storage.set(<span class="keyword">this</span>.STORAGE_KEY, items);
        <span class="keyword">this</span>.updateUI();
    },

    <span class="comment">// 상품 제거</span>
    removeItem(productId) {
        <span class="keyword">const</span> items = <span class="keyword">this</span>.getItems().filter(item => item.id !== productId);
        storage.set(<span class="keyword">this</span>.STORAGE_KEY, items);
        <span class="keyword">this</span>.updateUI();
    },

    <span class="comment">// 수량 변경</span>
    updateQuantity(productId, quantity) {
        <span class="keyword">const</span> items = <span class="keyword">this</span>.getItems();
        <span class="keyword">const</span> item = items.find(item => item.id === productId);
        <span class="keyword">if</span> (item) {
            item.quantity = quantity;
            storage.set(<span class="keyword">this</span>.STORAGE_KEY, items);
            <span class="keyword">this</span>.updateUI();
        }
    },

    <span class="comment">// 총액 계산</span>
    getTotal() {
        <span class="keyword">return</span> <span class="keyword">this</span>.getItems()
            .reduce((sum, item) => sum + item.price * item.quantity, <span class="number">0</span>);
    },

    <span class="comment">// UI 업데이트</span>
    updateUI() {
        <span class="keyword">const</span> count = <span class="keyword">this</span>.getItems().reduce((sum, item) => sum + item.quantity, <span class="number">0</span>);
        document.querySelector(<span class="string">'.cart-count'</span>).textContent = count;
    }
};</code></pre>
                        </div>

                        <h5 class="sub-title">실전 활용: 최근 본 상품</h5>
                        <div class="code-explain">
                            <h6><i class="fa-solid fa-clock-rotate-left"></i> 최근 본 상품 구현 핵심</h6>
                            <ul>
                                <li><strong>MAX_ITEMS</strong>: 최대 개수 제한으로 스토리지 용량 관리</li>
                                <li><strong>중복 제거 후 추가</strong>: filter로 기존 항목 제거 후 맨 앞에 추가 (unshift)</li>
                                <li><strong>slice</strong>: 배열이 최대 개수를 넘으면 오래된 항목 자동 제거</li>
                                <li><strong>타임스탬프</strong>: viewedAt으로 본 시간 기록 (정렬/필터링 용도)</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">상품 상세 페이지</span>
                            <span class="use-case-tag where">개인화 추천</span>
                            <span class="use-case-tag tip">최근 본 상품 위젯에 표시</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">최근 본 상품</span>
                            </div>
                            <pre><code><span class="comment">// 최근 본 상품 관리 (최대 10개 유지)</span>
<span class="keyword">const</span> recentProducts = {
    STORAGE_KEY: <span class="string">'recent_products'</span>,
    MAX_ITEMS: <span class="number">10</span>,

    add(product) {
        <span class="keyword">let</span> items = storage.get(<span class="keyword">this</span>.STORAGE_KEY, []);

        <span class="comment">// 기존 항목 제거 (중복 방지)</span>
        items = items.filter(item => item.id !== product.id);

        <span class="comment">// 맨 앞에 추가</span>
        items.unshift({
            id: product.id,
            name: product.name,
            image: product.image,
            price: product.price,
            viewedAt: <span class="keyword">new</span> Date().toISOString()
        });

        <span class="comment">// 최대 개수 유지</span>
        <span class="keyword">if</span> (items.length > <span class="keyword">this</span>.MAX_ITEMS) {
            items = items.slice(<span class="number">0</span>, <span class="keyword">this</span>.MAX_ITEMS);
        }

        storage.set(<span class="keyword">this</span>.STORAGE_KEY, items);
    },

    getAll() {
        <span class="keyword">return</span> storage.get(<span class="keyword">this</span>.STORAGE_KEY, []);
    }
};</code></pre>
                        </div>
                    </div>

                    <!-- ============================================ -->
                    <!-- 9. 고급 패턴 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-rocket"></i> 고급 패턴</h4>

                        <div class="info-box">
                            <p>성능 최적화, 무한 스크롤, 이미지 지연 로딩 등 실무에서 자주 사용하는 고급 패턴이다. 사용자 경험과 성능을 동시에 고려해야 하는 기능들이다.</p>
                        </div>

                        <h5 class="sub-title">무한 스크롤</h5>
                        <p class="desc-text">페이지 하단에 도달하면 자동으로 추가 컨텐츠를 로드한다. SNS 피드, 상품 목록 등에서 사용된다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-infinity"></i> 무한 스크롤의 핵심 원리</h6>
                            <ul>
                                <li><strong>Intersection Observer</strong>: 요소가 뷰포트에 들어오는지 감지하는 API</li>
                                <li><strong>loadingTrigger</strong>: 페이지 맨 아래에 배치된 감지용 요소</li>
                                <li><strong>rootMargin</strong>: '100px' 설정으로 100px 전에 미리 로드 시작</li>
                                <li><strong>isLoading 플래그</strong>: 중복 요청 방지를 위한 상태 관리</li>
                                <li><strong>hasMore</strong>: 더 불러올 데이터가 있는지 확인</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">SNS 피드</span>
                            <span class="use-case-tag where">상품 목록</span>
                            <span class="use-case-tag tip">스크롤 이벤트보다 성능 우수</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">Intersection Observer로 무한 스크롤</span>
                            </div>
                            <pre><code><span class="comment">// Intersection Observer를 활용한 무한 스크롤</span>
<span class="comment">// 로딩 트리거 요소가 보이면 다음 페이지 로드</span>
<span class="keyword">const</span> loadingTrigger = document.querySelector(<span class="string">'.loading-trigger'</span>);
<span class="keyword">const</span> itemsContainer = document.querySelector(<span class="string">'.items-container'</span>);
<span class="keyword">let</span> page = <span class="number">1</span>;
<span class="keyword">let</span> isLoading = <span class="boolean">false</span>;
<span class="keyword">let</span> hasMore = <span class="boolean">true</span>;

<span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="keyword">async</span> (entries) => {
    <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting && !isLoading && hasMore) {
        isLoading = <span class="boolean">true</span>;
        showSpinner();

        <span class="keyword">try</span> {
            <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`/api/items?page=</span><span class="interpolation">${page}</span><span class="string">`</span>);
            <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();

            <span class="keyword">if</span> (data.items.length === <span class="number">0</span>) {
                hasMore = <span class="boolean">false</span>;
                observer.disconnect();
                showEndMessage();
            } <span class="keyword">else</span> {
                appendItems(data.items);
                page++;
            }
        } <span class="keyword">catch</span> (error) {
            showError(<span class="string">'로드 실패'</span>);
        } <span class="keyword">finally</span> {
            isLoading = <span class="boolean">false</span>;
            hideSpinner();
        }
    }
}, {
    rootMargin: <span class="string">'100px'</span>  <span class="comment">// 100px 전에 미리 로드</span>
});

observer.observe(loadingTrigger);

<span class="keyword">function</span> <span class="function">appendItems</span>(items) {
    items.forEach(item => {
        <span class="keyword">const</span> el = document.createElement(<span class="string">'div'</span>);
        el.className = <span class="string">'item'</span>;
        el.innerHTML = <span class="string">`&lt;h3&gt;</span><span class="interpolation">${item.title}</span><span class="string">&lt;/h3&gt;&lt;p&gt;</span><span class="interpolation">${item.description}</span><span class="string">&lt;/p&gt;`</span>;
        itemsContainer.appendChild(el);
    });
}</code></pre>
                        </div>

                        <h5 class="sub-title">성능 최적화 패턴</h5>
                        <p class="desc-text">빈번하게 발생하는 이벤트(스크롤, 리사이즈, 입력)의 처리 횟수를 제한하여 성능을 최적화한다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-gauge-high"></i> 디바운스 vs 쓰로틀 차이점</h6>
                            <ul>
                                <li><strong>디바운스 (Debounce)</strong>: 마지막 이벤트 후 일정 시간 뒤 1회 실행. 연속 입력이 끝난 후 처리할 때 사용</li>
                                <li><strong>쓰로틀 (Throttle)</strong>: 일정 간격으로만 실행. 연속 이벤트 중에도 주기적으로 처리할 때 사용</li>
                                <li><strong>사용 예</strong>: 검색창 자동완성은 디바운스, 스크롤 위치 추적은 쓰로틀</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">검색창 자동완성</span>
                            <span class="use-case-tag where">창 리사이즈</span>
                            <span class="use-case-tag tip">연속 입력 완료 후 실행</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">디바운스 (Debounce)</span>
                            </div>
                            <pre><code><span class="comment">// 디바운스 - 마지막 이벤트 후 일정 시간 뒤 실행</span>
<span class="comment">// 검색창 입력, 창 리사이즈 등에 적합</span>
<span class="keyword">function</span> <span class="function">debounce</span>(func, delay) {
    <span class="keyword">let</span> timeoutId;
    <span class="keyword">return</span> (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func(...args), delay);
    };
}

<span class="comment">// 사용 예시: 검색</span>
<span class="keyword">const</span> debouncedSearch = debounce((query) => {
    fetchResults(query);
}, <span class="number">300</span>);  <span class="comment">// 300ms 대기</span>

searchInput.addEventListener(<span class="string">'input'</span>, (e) => debouncedSearch(e.target.value));

<span class="comment">// 사용 예시: 창 리사이즈</span>
<span class="keyword">const</span> debouncedResize = debounce(() => {
    recalculateLayout();
}, <span class="number">200</span>);

window.addEventListener(<span class="string">'resize'</span>, debouncedResize);</code></pre>
                        </div>

                        <div class="code-intro">
                            <span class="use-case-tag where">스크롤 이벤트</span>
                            <span class="use-case-tag where">마우스 이동 추적</span>
                            <span class="use-case-tag tip">일정 간격으로 실행</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">쓰로틀 (Throttle)</span>
                            </div>
                            <pre><code><span class="comment">// 쓰로틀 - 일정 간격으로만 실행</span>
<span class="comment">// 스크롤, 마우스 이동 등 연속 이벤트에 적합</span>
<span class="keyword">function</span> <span class="function">throttle</span>(func, limit) {
    <span class="keyword">let</span> inThrottle;
    <span class="keyword">return</span> (...args) => {
        <span class="keyword">if</span> (!inThrottle) {
            func(...args);
            inThrottle = <span class="boolean">true</span>;
            setTimeout(() => inThrottle = <span class="boolean">false</span>, limit);
        }
    };
}

<span class="comment">// 사용 예시: 스크롤</span>
<span class="keyword">const</span> throttledScroll = throttle(() => {
    updateScrollProgress();
}, <span class="number">100</span>);  <span class="comment">// 100ms마다 최대 1회 실행</span>

window.addEventListener(<span class="string">'scroll'</span>, throttledScroll);

<span class="comment">// requestAnimationFrame을 사용한 쓰로틀 (더 부드러움)</span>
<span class="keyword">function</span> <span class="function">rafThrottle</span>(func) {
    <span class="keyword">let</span> rafId = <span class="keyword">null</span>;
    <span class="keyword">return</span> (...args) => {
        <span class="keyword">if</span> (rafId) <span class="keyword">return</span>;
        rafId = requestAnimationFrame(() => {
            func(...args);
            rafId = <span class="keyword">null</span>;
        });
    };
}

window.addEventListener(<span class="string">'scroll'</span>, rafThrottle(handleScroll));</code></pre>
                        </div>

                        <h5 class="sub-title">이미지 지연 로딩</h5>
                        <p class="desc-text">이미지가 화면에 보일 때만 로드하여 초기 로딩 속도를 개선한다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-image"></i> 이미지 지연 로딩 원리</h6>
                            <ul>
                                <li><strong>data-src</strong>: 실제 이미지 URL을 data 속성에 저장</li>
                                <li><strong>placeholder</strong>: 초기에는 저용량 이미지나 블러 이미지 표시</li>
                                <li><strong>뷰포트 진입</strong>: Intersection Observer가 감지하면 실제 이미지 로드</li>
                                <li><strong>unobserve</strong>: 이미 로드된 이미지는 감시 해제로 메모리 절약</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">이미지 갤러리</span>
                            <span class="use-case-tag where">상품 목록 페이지</span>
                            <span class="use-case-tag tip">초기 로딩 속도 개선</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">Intersection Observer 이미지 Lazy Loading</span>
                            </div>
                            <pre><code><span class="comment">// 이미지가 뷰포트에 들어올 때 로드</span>
<span class="keyword">const</span> lazyImages = document.querySelectorAll(<span class="string">'img.lazy'</span>);

<span class="keyword">const</span> imageObserver = <span class="keyword">new</span> IntersectionObserver((entries) => {
    entries.forEach(entry => {
        <span class="keyword">if</span> (entry.isIntersecting) {
            <span class="keyword">const</span> img = entry.target;

            <span class="comment">// data-src → src 로 변경</span>
            img.src = img.dataset.src;

            <span class="comment">// srcset이 있으면 적용</span>
            <span class="keyword">if</span> (img.dataset.srcset) {
                img.srcset = img.dataset.srcset;
            }

            <span class="comment">// 로드 완료 시 스타일 적용</span>
            img.onload = () => {
                img.classList.remove(<span class="string">'lazy'</span>);
                img.classList.add(<span class="string">'loaded'</span>);
            };

            imageObserver.unobserve(img);
        }
    });
}, {
    rootMargin: <span class="string">'50px'</span>  <span class="comment">// 50px 전에 미리 로드</span>
});

lazyImages.forEach(img => imageObserver.observe(img));

<span class="comment">/* HTML 예시 */</span>
<span class="comment">// &lt;img class="lazy" data-src="image.jpg" data-srcset="image-2x.jpg 2x"</span>
<span class="comment">//      src="placeholder.jpg" alt="설명"&gt;</span>

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .lazy { filter: blur(10px); transition: filter 0.3s; }</span>
<span class="comment">// .loaded { filter: none; }</span></code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">네이티브 loading="lazy" 폴백</span>
                            </div>
                            <pre><code><span class="comment">// 네이티브 lazy loading 지원 여부 확인 후 폴백</span>
<span class="keyword">if</span> (<span class="string">'loading'</span> <span class="keyword">in</span> HTMLImageElement.prototype) {
    <span class="comment">// 네이티브 지원 - loading 속성 추가만 하면 됨</span>
    document.querySelectorAll(<span class="string">'img.lazy'</span>).forEach(img => {
        img.loading = <span class="string">'lazy'</span>;
        img.src = img.dataset.src;
    });
} <span class="keyword">else</span> {
    <span class="comment">// 미지원 브라우저 - Intersection Observer 사용</span>
    <span class="comment">// 위의 코드 사용</span>
}

<span class="comment">/* 또는 HTML에서 직접 사용 (간단한 방법) */</span>
<span class="comment">// &lt;img src="image.jpg" loading="lazy" alt="설명"&gt;</span></code></pre>
                        </div>

                        <h5 class="sub-title">부드러운 스크롤</h5>
                        <p class="desc-text">앵커 링크 클릭 시 부드럽게 이동하는 기능이다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-arrow-down"></i> 부드러운 스크롤 구현 포인트</h6>
                            <ul>
                                <li><strong>behavior: 'smooth'</strong>: CSS scroll-behavior와 동일한 효과를 JavaScript로 구현</li>
                                <li><strong>headerOffset</strong>: 고정 헤더가 있을 경우 그 높이만큼 빼줘야 정확한 위치로 이동</li>
                                <li><strong>getBoundingClientRect()</strong>: 요소의 현재 화면 상 위치를 계산</li>
                                <li><strong>history.pushState</strong>: URL 해시 업데이트로 북마크/공유 가능</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">원페이지 사이트</span>
                            <span class="use-case-tag where">목차 네비게이션</span>
                            <span class="use-case-tag tip">고정 헤더 높이 고려 필수</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">부드러운 스크롤 이동</span>
                            </div>
                            <pre><code><span class="comment">// 고정 헤더를 고려한 부드러운 스크롤</span>
<span class="keyword">function</span> <span class="function">smoothScrollTo</span>(target) {
    <span class="keyword">const</span> element = document.querySelector(target);
    <span class="keyword">if</span> (!element) <span class="keyword">return</span>;

    <span class="keyword">const</span> headerOffset = <span class="number">80</span>;  <span class="comment">// 고정 헤더 높이</span>
    <span class="keyword">const</span> elementPosition = element.getBoundingClientRect().top;
    <span class="keyword">const</span> offsetPosition = elementPosition + window.scrollY - headerOffset;

    window.scrollTo({
        top: offsetPosition,
        behavior: <span class="string">'smooth'</span>
    });
}

<span class="comment">// 모든 앵커 링크에 적용</span>
document.querySelectorAll(<span class="string">'a[href^="#"]'</span>).forEach(anchor => {
    anchor.addEventListener(<span class="string">'click'</span>, (e) => {
        e.preventDefault();
        <span class="keyword">const</span> targetId = anchor.getAttribute(<span class="string">'href'</span>);
        smoothScrollTo(targetId);

        <span class="comment">// URL 해시 업데이트 (선택사항)</span>
        history.pushState(<span class="keyword">null</span>, <span class="keyword">null</span>, targetId);
    });
});</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">맨 위로 버튼</span>
                            </div>
                            <pre><code><span class="comment">// 일정 스크롤 후 나타나는 맨 위로 버튼</span>
<span class="keyword">const</span> scrollTopBtn = document.querySelector(<span class="string">'.scroll-top'</span>);

<span class="comment">// 스크롤 위치에 따라 버튼 표시/숨김</span>
window.addEventListener(<span class="string">'scroll'</span>, throttle(() => {
    <span class="keyword">if</span> (window.scrollY > <span class="number">500</span>) {
        scrollTopBtn.classList.add(<span class="string">'visible'</span>);
    } <span class="keyword">else</span> {
        scrollTopBtn.classList.remove(<span class="string">'visible'</span>);
    }
}, <span class="number">100</span>));

<span class="comment">// 클릭 시 맨 위로</span>
scrollTopBtn.addEventListener(<span class="string">'click'</span>, () => {
    window.scrollTo({ top: <span class="number">0</span>, behavior: <span class="string">'smooth'</span> });
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// .scroll-top { position: fixed; bottom: 30px; right: 30px;</span>
<span class="comment">//   opacity: 0; visibility: hidden; transition: 0.3s; }</span>
<span class="comment">// .scroll-top.visible { opacity: 1; visibility: visible; }</span></code></pre>
                        </div>

                        <h5 class="sub-title">반응형 처리</h5>
                        <p class="desc-text">화면 크기에 따라 다른 동작을 하는 JavaScript 반응형 처리다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-mobile-screen"></i> JavaScript 반응형 처리 핵심</h6>
                            <ul>
                                <li><strong>window.matchMedia()</strong>: CSS 미디어 쿼리를 JavaScript에서 사용</li>
                                <li><strong>.matches</strong>: 현재 미디어 쿼리 충족 여부를 boolean으로 반환</li>
                                <li><strong>change 이벤트</strong>: 화면 크기 변경을 실시간 감지</li>
                                <li><strong>CSS vs JS</strong>: 스타일만 변경은 CSS, 기능/동작 변경은 JS 사용</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">모바일/데스크탑 전환</span>
                            <span class="use-case-tag where">반응형 네비게이션</span>
                            <span class="use-case-tag tip">resize 이벤트보다 효율적</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">미디어 쿼리 감지</span>
                            </div>
                            <pre><code><span class="comment">// matchMedia로 반응형 분기 처리</span>
<span class="keyword">const</span> mobileQuery = window.matchMedia(<span class="string">'(max-width: 768px)'</span>);

<span class="comment">// 현재 상태 확인</span>
<span class="keyword">if</span> (mobileQuery.matches) {
    initMobileUI();
} <span class="keyword">else</span> {
    initDesktopUI();
}

<span class="comment">// 변경 감지</span>
mobileQuery.addEventListener(<span class="string">'change'</span>, (e) => {
    <span class="keyword">if</span> (e.matches) {
        console.log(<span class="string">'모바일 화면'</span>);
        switchToMobile();
    } <span class="keyword">else</span> {
        console.log(<span class="string">'데스크탑 화면'</span>);
        switchToDesktop();
    }
});</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">브레이크포인트 관리자</span>
                            </div>
                            <pre><code><span class="comment">// 여러 브레이크포인트를 체계적으로 관리</span>
<span class="keyword">const</span> breakpoints = {
    sm: <span class="string">'(max-width: 576px)'</span>,
    md: <span class="string">'(min-width: 577px) and (max-width: 768px)'</span>,
    lg: <span class="string">'(min-width: 769px) and (max-width: 1024px)'</span>,
    xl: <span class="string">'(min-width: 1025px)'</span>
};

<span class="keyword">function</span> <span class="function">getBreakpoint</span>() {
    <span class="keyword">for</span> (<span class="keyword">const</span> [name, query] <span class="keyword">of</span> Object.entries(breakpoints)) {
        <span class="keyword">if</span> (window.matchMedia(query).matches) {
            <span class="keyword">return</span> name;
        }
    }
    <span class="keyword">return</span> <span class="string">'xl'</span>;
}

<span class="comment">// 현재 브레이크포인트 확인</span>
console.log(<span class="string">'현재:'</span>, getBreakpoint());

<span class="comment">// 특정 브레이크포인트 이하인지 확인</span>
<span class="keyword">function</span> <span class="function">isMobile</span>() {
    <span class="keyword">return</span> window.matchMedia(<span class="string">'(max-width: 768px)'</span>).matches;
}</code></pre>
                        </div>

                        <h5 class="sub-title">데이터 페칭 패턴</h5>
                        <p class="desc-text">API 호출과 에러 처리, 로딩 상태 관리 패턴이다.</p>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-cloud-arrow-down"></i> 데이터 페칭 핵심 패턴</h6>
                            <ul>
                                <li><strong>래퍼 함수</strong>: 공통 설정(baseURL, headers)을 재사용하는 함수로 코드 중복 제거</li>
                                <li><strong>상태 관리</strong>: 로딩/성공/에러 세 가지 상태를 명확히 구분</li>
                                <li><strong>try-catch-finally</strong>: 에러 처리와 정리 작업을 분리</li>
                                <li><strong>재시도 로직</strong>: 지수 백오프(1초, 2초, 4초...)로 서버 부하 감소</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">API 통신</span>
                            <span class="use-case-tag where">데이터 목록 표시</span>
                            <span class="use-case-tag tip">사용자 경험 개선 필수</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">Fetch 래퍼 함수</span>
                            </div>
                            <pre><code><span class="comment">// API 호출을 간편하게 만드는 래퍼</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">api</span>(endpoint, options = {}) {
    <span class="keyword">const</span> baseURL = <span class="string">'/api'</span>;
    <span class="keyword">const</span> defaultHeaders = {
        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>
    };

    <span class="keyword">try</span> {
        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`</span><span class="interpolation">${baseURL}${endpoint}</span><span class="string">`</span>, {
            ...options,
            headers: {
                ...defaultHeaders,
                ...options.headers
            }
        });

        <span class="keyword">if</span> (!response.ok) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">`HTTP </span><span class="interpolation">${response.status}</span><span class="string">`</span>);
        }

        <span class="keyword">return</span> <span class="keyword">await</span> response.json();
    } <span class="keyword">catch</span> (error) {
        console.error(<span class="string">'API Error:'</span>, error);
        <span class="keyword">throw</span> error;
    }
}

<span class="comment">// 사용 예시</span>
<span class="keyword">const</span> users = <span class="keyword">await</span> api(<span class="string">'/users'</span>);
<span class="keyword">const</span> newUser = <span class="keyword">await</span> api(<span class="string">'/users'</span>, {
    method: <span class="string">'POST'</span>,
    body: JSON.stringify({ name: <span class="string">'홍길동'</span> })
});</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">로딩 상태 관리</span>
                            </div>
                            <pre><code><span class="comment">// 데이터 페칭 시 로딩/에러/데이터 상태 관리</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">fetchWithState</span>(url, container) {
    <span class="keyword">const</span> loader = container.querySelector(<span class="string">'.loader'</span>);
    <span class="keyword">const</span> errorEl = container.querySelector(<span class="string">'.error'</span>);
    <span class="keyword">const</span> content = container.querySelector(<span class="string">'.content'</span>);

    <span class="comment">// 로딩 시작</span>
    loader.style.display = <span class="string">'block'</span>;
    errorEl.style.display = <span class="string">'none'</span>;
    content.style.display = <span class="string">'none'</span>;

    <span class="keyword">try</span> {
        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);
        <span class="keyword">if</span> (!response.ok) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'로드 실패'</span>);
        <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();

        <span class="comment">// 성공</span>
        content.innerHTML = renderData(data);
        content.style.display = <span class="string">'block'</span>;

    } <span class="keyword">catch</span> (error) {
        <span class="comment">// 에러</span>
        errorEl.textContent = error.message;
        errorEl.style.display = <span class="string">'block'</span>;

    } <span class="keyword">finally</span> {
        <span class="comment">// 로딩 완료</span>
        loader.style.display = <span class="string">'none'</span>;
    }
}</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">재시도 로직</span>
                            </div>
                            <pre><code><span class="comment">// 실패 시 자동 재시도</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">fetchWithRetry</span>(url, maxRetries = <span class="number">3</span>, delay = <span class="number">1000</span>) {
    <span class="keyword">let</span> lastError;

    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < maxRetries; i++) {
        <span class="keyword">try</span> {
            <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);
            <span class="keyword">if</span> (!response.ok) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">`HTTP </span><span class="interpolation">${response.status}</span><span class="string">`</span>);
            <span class="keyword">return</span> <span class="keyword">await</span> response.json();

        } <span class="keyword">catch</span> (error) {
            lastError = error;
            console.log(<span class="string">`시도 </span><span class="interpolation">${i + 1}</span><span class="string"> 실패, 재시도 중...`</span>);

            <span class="keyword">if</span> (i < maxRetries - <span class="number">1</span>) {
                <span class="comment">// 지수 백오프 (1초, 2초, 4초...)</span>
                <span class="keyword">await</span> <span class="keyword">new</span> Promise(r => setTimeout(r, delay * Math.pow(<span class="number">2</span>, i)));
            }
        }
    }

    <span class="keyword">throw</span> lastError;
}</code></pre>
                        </div>
                    </div>

                    <!-- ============================================ -->
                    <!-- 10. 애니메이션 패턴 -->
                    <!-- ============================================ -->
                    <div class="practical-section">
                        <h4 class="practical-title"><i class="fa-solid fa-film"></i> 애니메이션 패턴</h4>

                        <div class="info-box">
                            <p>JavaScript와 CSS를 조합한 애니메이션 패턴이다. CSS 애니메이션이 성능이 좋지만, 복잡한 제어가 필요하면 JavaScript를 사용한다.
                                requestAnimationFrame은 60fps로 부드러운 애니메이션을 구현할 수 있다.</p>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-play"></i> requestAnimationFrame 핵심 개념</h6>
                            <ul>
                                <li><strong>requestAnimationFrame</strong>: 브라우저의 리페인트 주기(60fps)에 맞춰 콜백 실행</li>
                                <li><strong>performance.now()</strong>: 고정밀 타임스탬프로 정확한 시간 계산</li>
                                <li><strong>이징 함수</strong>: 시작/끝에서 속도를 조절해 자연스러운 움직임 구현</li>
                                <li><strong>progress</strong>: 0~1 사이 값으로 애니메이션 진행률 표현</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">커스텀 애니메이션</span>
                            <span class="use-case-tag where">게임 개발</span>
                            <span class="use-case-tag tip">CSS보다 세밀한 제어 가능</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">requestAnimationFrame 애니메이션</span>
                            </div>
                            <pre><code><span class="comment">// requestAnimationFrame으로 부드러운 애니메이션</span>
<span class="comment">// CSS로 표현하기 어려운 복잡한 애니메이션에 사용</span>
<span class="keyword">function</span> <span class="function">animate</span>(element, property, from, to, duration) {
    <span class="keyword">const</span> start = performance.now();

    <span class="keyword">function</span> <span class="function">step</span>(timestamp) {
        <span class="keyword">const</span> elapsed = timestamp - start;
        <span class="keyword">const</span> progress = Math.min(elapsed / duration, <span class="number">1</span>);

        <span class="comment">// easeOutCubic 이징</span>
        <span class="keyword">const</span> eased = <span class="number">1</span> - Math.pow(<span class="number">1</span> - progress, <span class="number">3</span>);

        <span class="keyword">const</span> current = from + (to - from) * eased;
        element.style[property] = current + <span class="string">'px'</span>;

        <span class="keyword">if</span> (progress < <span class="number">1</span>) {
            requestAnimationFrame(step);
        }
    }

    requestAnimationFrame(step);
}

<span class="comment">// 사용 예시</span>
animate(box, <span class="string">'left'</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">1000</span>);  <span class="comment">// 1초 동안 0→300px</span></code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-leaf"></i> 스프링 애니메이션 물리 원리</h6>
                            <ul>
                                <li><strong>stiffness (강성)</strong>: 스프링이 얼마나 빠르게 목표로 당겨지는지 결정</li>
                                <li><strong>damping (감쇠)</strong>: 진동이 얼마나 빨리 멈추는지 결정 (0.8~0.95 권장)</li>
                                <li><strong>velocity (속도)</strong>: 매 프레임마다 누적되어 자연스러운 관성 표현</li>
                                <li><strong>종료 조건</strong>: 속도가 거의 0이 되면 애니메이션 중지</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">드래그 후 원위치</span>
                            <span class="use-case-tag where">팝업 등장 효과</span>
                            <span class="use-case-tag tip">iOS 스타일 자연스러운 움직임</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">스프링 애니메이션</span>
                            </div>
                            <pre><code><span class="comment">// 물리 기반 스프링 애니메이션</span>
<span class="comment">// 자연스러운 바운스 효과</span>
<span class="keyword">function</span> <span class="function">springAnimation</span>(element, targetX, targetY) {
    <span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">0</span>;
    <span class="keyword">let</span> vx = <span class="number">0</span>, vy = <span class="number">0</span>;
    <span class="keyword">const</span> stiffness = <span class="number">0.1</span>;  <span class="comment">// 스프링 강도</span>
    <span class="keyword">const</span> damping = <span class="number">0.8</span>;    <span class="comment">// 감쇠 (1에 가까울수록 빠르게 멈춤)</span>

    <span class="keyword">function</span> <span class="function">update</span>() {
        <span class="comment">// 목표까지의 힘 계산</span>
        <span class="keyword">const</span> fx = (targetX - x) * stiffness;
        <span class="keyword">const</span> fy = (targetY - y) * stiffness;

        <span class="comment">// 속도 업데이트 (감쇠 적용)</span>
        vx = vx * damping + fx;
        vy = vy * damping + fy;

        <span class="comment">// 위치 업데이트</span>
        x += vx;
        y += vy;

        element.style.transform = <span class="string">`translate(</span><span class="interpolation">${x}</span><span class="string">px, </span><span class="interpolation">${y}</span><span class="string">px)`</span>;

        <span class="comment">// 거의 멈출 때까지 계속</span>
        <span class="keyword">if</span> (Math.abs(vx) > <span class="number">0.01</span> || Math.abs(vy) > <span class="number">0.01</span>) {
            requestAnimationFrame(update);
        }
    }

    requestAnimationFrame(update);
}</code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-toggle-on"></i> CSS 클래스 토글 방식</h6>
                            <ul>
                                <li><strong>장점</strong>: CSS에서 @keyframes 정의, JS는 클래스만 토글 - 역할 분리가 깔끔</li>
                                <li><strong>animationend</strong>: 애니메이션 종료 시점을 감지하는 이벤트</li>
                                <li><strong>once: true</strong>: 이벤트 리스너를 1회만 실행 후 자동 제거</li>
                                <li><strong>활용</strong>: 버튼 클릭 피드백, 알림 효과, 유효성 검사 실패 표시 등</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">버튼 클릭 피드백</span>
                            <span class="use-case-tag where">에러 알림 흔들림</span>
                            <span class="use-case-tag tip">CSS와 JS 조합 추천 방식</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">CSS 클래스 토글 애니메이션</span>
                            </div>
                            <pre><code><span class="comment">// CSS 트랜지션과 JavaScript 조합</span>
<span class="comment">// 간단한 상태 전환 애니메이션</span>
<span class="keyword">function</span> <span class="function">toggleAnimation</span>(element, className) {
    element.classList.add(className);

    <span class="comment">// 애니메이션 끝나면 클래스 제거</span>
    element.addEventListener(<span class="string">'animationend'</span>, () => {
        element.classList.remove(className);
    }, { once: <span class="boolean">true</span> });
}

<span class="comment">// 버튼 클릭 시 흔들림 효과</span>
button.addEventListener(<span class="string">'click'</span>, () => {
    toggleAnimation(button, <span class="string">'shake'</span>);
});

<span class="comment">/* 필요한 CSS */</span>
<span class="comment">// @keyframes shake {</span>
<span class="comment">//   0%, 100% { transform: translateX(0); }</span>
<span class="comment">//   25% { transform: translateX(-10px); }</span>
<span class="comment">//   75% { transform: translateX(10px); }</span>
<span class="comment">// }</span>
<span class="comment">// .shake { animation: shake 0.3s ease; }</span></code></pre>
                        </div>

                        <div class="code-explain">
                            <h6><i class="fa-solid fa-keyboard"></i> 타이핑 애니메이션 구현 원리</h6>
                            <ul>
                                <li><strong>async/await</strong>: 각 글자 출력 사이에 딜레이를 주기 위해 비동기 함수 사용</li>
                                <li><strong>for...of</strong>: 문자열을 한 글자씩 순회</li>
                                <li><strong>Promise + setTimeout</strong>: await로 일정 시간 대기하는 패턴</li>
                                <li><strong>slice(0, -1)</strong>: 문자열 끝에서 한 글자씩 제거 (지우기 효과)</li>
                                <li><strong>무한 루프</strong>: while(true)로 문장들을 계속 순환</li>
                            </ul>
                        </div>
                        <div class="code-intro">
                            <span class="use-case-tag where">히어로 섹션 타이틀</span>
                            <span class="use-case-tag where">포트폴리오 소개</span>
                            <span class="use-case-tag tip">커서 깜빡임 CSS와 함께 사용</span>
                        </div>

                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">JavaScript</span>
                                <span class="code-title">타이핑 애니메이션</span>
                            </div>
                            <pre><code><span class="comment">// 타자기처럼 글자가 하나씩 나타나는 효과</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">typeText</span>(element, text, speed = <span class="number">50</span>) {
    element.textContent = <span class="string">''</span>;

    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> text) {
        element.textContent += char;
        <span class="keyword">await</span> <span class="keyword">new</span> Promise(r => setTimeout(r, speed));
    }
}

<span class="comment">// 여러 문장 순환</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="function">typeLoop</span>(element, texts, speed = <span class="number">50</span>) {
    <span class="keyword">let</span> index = <span class="number">0</span>;

    <span class="keyword">while</span> (<span class="boolean">true</span>) {
        <span class="keyword">await</span> typeText(element, texts[index], speed);
        <span class="keyword">await</span> <span class="keyword">new</span> Promise(r => setTimeout(r, <span class="number">2000</span>));  <span class="comment">// 2초 대기</span>

        <span class="comment">// 지우기 효과</span>
        <span class="keyword">while</span> (element.textContent.length > <span class="number">0</span>) {
            element.textContent = element.textContent.slice(<span class="number">0</span>, -<span class="number">1</span>);
            <span class="keyword">await</span> <span class="keyword">new</span> Promise(r => setTimeout(r, <span class="number">30</span>));
        }

        index = (index + <span class="number">1</span>) % texts.length;
    }
}

<span class="comment">// 사용 예시</span>
typeLoop(document.querySelector(<span class="string">'.typing-text'</span>), [
    <span class="string">'웹 개발자'</span>,
    <span class="string">'프론트엔드 개발자'</span>,
    <span class="string">'크리에이터'</span>
]);</code></pre>
                        </div>
                    </div>

                    <div class="highlight-box success">
                        <div class="highlight-icon"><i class="fa-solid fa-check"></i></div>
                        <div class="highlight-content">
                            <h5>JavaScript 실무 인터랙션 학습 완료!</h5>
                            <p>스크롤, 클릭, 마우스, 키보드, 터치, 폼, 알림, 로컬 스토리지, 고급 패턴, 애니메이션까지 모두 학습했다. 이 코드들을 프로젝트에 직접 복사해서
                                사용해보자. 더 복잡한 인터랙션이 필요하다면 GSAP, Framer Motion, Three.js 같은 라이브러리도 도전해보자!</p>
                        </div>
                    </div>
                </article>
            </div>
        </section>

    </main>

    <!-- 푸터 -->
    <footer class="footer">
        <div class="footer-content">
            <p><i class="fa-brands fa-js-square"></i> JavaScript 완벽 가이드 | 웹 개발의 핵심 언어</p>
            <p class="copyright">Educational Purpose Only</p>
        </div>
    </footer>

    <!-- 스크롤 탑 버튼 -->
    <button class="scroll-top-btn">
        <i class="fa-solid fa-arrow-up"></i>
    </button>

    <!-- Swiper JS -->
    <script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
    <!-- 스크립트 -->
    <script src="script.js"></script>
</body>

</html>